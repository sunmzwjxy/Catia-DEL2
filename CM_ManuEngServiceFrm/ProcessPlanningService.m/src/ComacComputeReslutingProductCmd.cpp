//===================================================================
// COPYRIGHT Comac 2021/12/02
//===================================================================
// ComacComputeReslutingProductCmd.cpp
// Header definition of class ComacComputeReslutingProductCmd
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2021/12/02 Creation: Code generated by the 3DS wizard
//===================================================================

#include "ComacComputeReslutingProductCmd.h"
// System
#include "CATBaseUnknown.h" 
#include "CATUnicodeString.h"
#include "CATBoolean.h"
#include "CATLISTP_Declare.h" 
#include "CATInstantiateComponent.h"
#include "CATLISTP_CATBaseUnknown.h"
#include "CATLISTV_CATBaseUnknown.h"
#include "CATListOfCATString.h"
#include "CATCollec.h"
//#include "ClsOperationOfExcel.h"

// ObjectModelerBase
#include "CATOmbLifeCycleRootsBag.h"
#include "CATOmbObjectInContext.h"
#include "CATIAlias.h"

// CATPLMComponentInterfaces
#include "CATIPLMNavReference.h"
#include "CATPLMCoreType.h"
#include "CATPLMSessionServices.h"
#include "CATListPtrCATIPLMNavEntity.h"
#include "CATIPLMNavEntity.h"
#include "CATIPLMNavInstance.h"
#include "CATIPLMNavOccurrence.h"
#include "CATListPtrCATIPLMNavOccurrence.h"

// ProductStructureInterfaces
#include "CATIPLMProducts.h"
#include "CATIPLMRepInstances.h"
#include "CATIPrdObject.h"
#include "CATIPrdOccurrenceMngt.h"
#include "CATPrdGetOccurrenceMngt.h"

// CATPLMIntegrationAccess
#include "CATAdpPLMExpandSpecification.h"
#include "CATAdpPLMExpandFilter.h"

//PLMWorkspaceInterfaces 
#include "CATPLMPersistentFilterServices.h"
#include "CATWSPCaptureServices.h"

// CATPLMIntegrationUse
#include "CATAdpSaver.h"
#include "CATAdpOpenParameters.h"
#include "CATAdpOpener.h"


//KnowledgeInterfaces 
#include "CATCkeObjectAttrReadServices.h"
#include "CATCkeObjectAttrWriteServices.h"
#include "CATCkeGlobalFunctions.h"
#include "CATICkeObject.h"

//CATPLMIdentificationAccess 
#include "CATListPtrCATIAdpPLMIdentificator.h"
//#include "CATIAInterferenceResult.h"
#include "CATIPLMComponent.h"
#include "CATIAdpType.h"

//VisualizationInterfaces 
#include "CATIBuildPath.h"
#include "CATPathElement.h"

//Mathematics 
#include "CATMathPoint.h"

//PLMDocumentInterfaces 
#include "PLMIDocument.h"
#include "PLMDocumentServices.h"

//PLMDictionaryNavServices 
#include "PLMIDocument.h"
#include "CATCkePLMNavPublicServices.h"

//SystemTS
#include "CATToken.h"

// 引用荣奇现有的库
#include "CUSCAAUtilService.h"
#include "PPRUtity.h"

//CATPLMComponentInterfaces Framework
#include "CATPLMSessionServices.h"

//Compute result product
#include "DELIPPRProcessOutputComputeAuth.h"
#include "DELIPPRProcessOccAuth.h"

#include "DELIPPRUIServices.h"			// 窗口下搜索maroot

// C++ Library
#include <iostream.h>
#include <fstream>
#include <comdef.h>
#include <vector>
using  namespace  std;



#include "CATCreateExternalObject.h"
CATCreateClass( ComacComputeReslutingProductCmd);

//-------------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------------
ComacComputeReslutingProductCmd::ComacComputeReslutingProductCmd() :
CATCommand (NULL, "ComacComputeReslutingProductCmd")
{
	//CUSCAAUtilService::ErrorMessage("info..", "12123");
	//1 遍历找到 当前窗口下的MA 根root！
	DELIPPRUIServices* piPPRUIServices = NULL;
	::CATInstantiateComponent("DELPPRUIServices", IID_DELIPPRUIServices, (void **)&piPPRUIServices);
	if (NULL == piPPRUIServices)
	{
		CUSCAAUtilService::ErrorMessage("info..", "不能启动 DELIPPRUIServices ！");
		RequestDelayedDestruction();
		return;
	}

	HRESULT rc = E_FAIL;
	CATListValCATBaseUnknown_var iospRoots;
	DELIPPRUIServices::PPRRootType iRootType = 2 /*PPRRootType::PROCESS*/ /*PPRRootTypeValues::PROCESS*/;
	rc = piPPRUIServices->GetPPRRootsFromCurrentEditor(iospRoots, iRootType);
	int sizeofMARoots = iospRoots.Size();

	cout << endl;
	cout << "# sizeofMARoots: " << sizeofMARoots << endl;

	if (FAILED(rc) || (sizeofMARoots == 0) )
	{
		CUSCAAUtilService::ErrorMessage("info..", "当前窗口不含有Process 根节点！");
		RequestDelayedDestruction(); 
		return;
	}
	
	CATUnicodeString sRefType = CUSCAAUtilService::GetObjectKnowledgeType(iospRoots[1]);
	cout << "#   iospRoots[1] 类型: " << sRefType << endl << endl << endl;			// PPRContext	

	if (sRefType == TYPE_MBOMAssembly)
	{
		//_pMARootRef = iospRoots[1];
		rc = iospRoots[1]->QueryInterface(IID_CATIPLMNavReference, (void **)&_pMARootRef);

		if (FAILED(rc))
		{
			cout <<  "==== FAILED  ==== >> QI IID_CATIPLMNavReference  ! " << endl;
			return;
		}
		cout <<  "==== OK ==== >> QI IID_CATIPLMNavReference ! " << endl;
		cout << "# 当前窗口含有: " << TYPE_MBOMAssembly << "   " << CUSCAAUtilService::GetAliasName(_pMARootRef) << endl;
	}
	else
	{
		cout << "# 当前窗口不含有: " << TYPE_MBOMAssembly << endl;
		CUSCAAUtilService::ErrorMessage("info..", "当前窗口不含有类型为："+ TYPE_MBOMAssembly +" 的 Process 根节点！");
		RequestDelayedDestruction();
		return;
	}
	//RequestDelayedDestruction();		// 构造不需要！
	RequestStatusChange (CATCommandMsgRequestSharedMode);
}

//-------------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------------
ComacComputeReslutingProductCmd::~ComacComputeReslutingProductCmd()
{

}


//  Overload this method: when your command gains focus
//
// Activates a command.
//   iFromClient :The command that requests to activate the current one.
//   iEvtDat :The notification sent.
// ----------------------------------------------------
CATStatusChangeRC ComacComputeReslutingProductCmd::Activate( CATCommand * iFromClient, CATNotification * iEvtDat)
{
	// 2 递归_pMARootRef寻找 符合的createAssmbly list Occ    list 条件：
	// 所有者： 自己  owner   / V_user			（选用不含V_的属性 key）
	// 状态： 工作中  current / V_maturity
	HRESULT rc = E_FAIL;
	CATIPLMNavOccurrence_var spRootProcessOcc;
	rc = GetOccurrenceFromProcessReference(_pMARootRef, spRootProcessOcc);
	if (FAILED(rc))
	{
		cout <<  "==== FAILED  ==== >> GetOccurrenceFromProcessReference ! " << endl;
		RequestDelayedDestruction();
		return (CATStatusChangeRCAborted);
	}
	cout <<   "==== OK ==== >> GetOccurrenceFromProcessReference ! " << endl;

	CATListPtrCATIPLMNavOccurrence		oNavOccChild;		// 符合的occ child
	rc = BrowseReference(_pMARootRef, spRootProcessOcc, 0, oNavOccChild);

	if (FAILED(rc))
	{
		cout <<   "==== FAILED  ==== >> BrowseReference ! " << endl;
		RequestDelayedDestruction();
		return (CATStatusChangeRCAborted);
	}
	cout <<  "==== OK ==== >> BrowseReference ! " << endl;


	// 3 自叶子向上 compute 计算
	rc = ComputeResultingProduct(oNavOccChild);
	if (FAILED(rc))
	{
		cout << "==== FAILED  ==== >> ComputeResultingProduct ! " << endl;
		RequestDelayedDestruction();
		return (CATStatusChangeRCAborted);
	}
	cout << "==== OK ==== >> ComputeResultingProduct ! " << endl;

	// 4 保存当前list―― 前台暂时先不保存！

	RequestDelayedDestruction();
	return (CATStatusChangeRCCompleted);
}

//  Overload this method: when your command loses focus
//
// Deactivates a command.
//   iFromClient :The command that requests to activate the current one.
//   iEvtDat :The notification sent.
// ----------------------------------------------------
CATStatusChangeRC ComacComputeReslutingProductCmd::Desactivate( CATCommand * iFromClient, CATNotification * iEvtDat)
{
	RequestDelayedDestruction();

return (CATStatusChangeRCCompleted);
}

//  Overload this method: when your command is canceled
//
// Cancel a command.
//   iFromClient :The command that requests to activate the current one.
//   iEvtDat :The notification sent.
// ----------------------------------------------------
CATStatusChangeRC ComacComputeReslutingProductCmd::Cancel( CATCommand * iFromClient, CATNotification * iEvtDat)
{
RequestDelayedDestruction();
return (CATStatusChangeRCCompleted);
}
//fengy 2021.12.1 根据 ref \ contextFatherOcc 获取Occ 
CATIPLMNavOccurrence_var ComacComputeReslutingProductCmd::GetOccFromRef(CATIPLMNavOccurrence_var ispOccOnFarther, CATIPLMNavReference_var ispRef)
{
	if (ispOccOnFarther != NULL_var && ispRef != NULL_var)
	{
		//cout<<"在"<<GetObjTitle(spOccOnFarther)<<"下获取"<<GetObjTitle(spIns)<<"的Occ"<<endl;

		CATListPtrCATIPLMNavOccurrence listOccOnRef;
		ispRef->ListRelatedOccurrences(ispOccOnFarther, listOccOnRef);
		cout << "GetOccFromRef size:" << listOccOnRef.Size() << endl;

		if (listOccOnRef.Size() == 1)
		{
			return listOccOnRef[1];
		}
	}

	return NULL_var;
}
// fengy 2021.12.1 改写 CAAProductStructure.edu\CAAPstBrowsingProductModel.m\src\CAAPstBrowsingProductModel.cpp 
HRESULT ComacComputeReslutingProductCmd::BrowseReference(CATIPLMNavReference* ipiNavRef, CATIPLMNavOccurrence * iRootProcessOcc, int iDepth, CATListPtrCATIPLMNavOccurrence& oNavOccChild)
{
	if (NULL == ipiNavRef) return E_INVALIDARG;

	// Seek the CATIPLMNavEntity* from ipiNavRef
	CATIPLMNavEntity* piNavEnt = NULL;
	HRESULT rc = E_FAIL;
	CATPLMCoreType coreType;
	CATListPtrCATIPLMNavEntity childrenList;


	// ===========================================================================================================
	// 5-0	: 提取ref 当前的type
	// ===========================================================================================================
	//hr = PrintPLMComponent(piNavEnt, iAllAtributes, iDepth);			// 打印当前 ref' 的属性 externalID
	CATUnicodeString sType = GetKnowledgeType(ipiNavRef, iDepth);
	if (sType == "CreateAssembly")
	{
		//oNavRefChild.Append(ipiNavRef);
		CATIPLMNavOccurrence_var  spOccContext = iRootProcessOcc;

		CATIPLMNavOccurrence_var spCurOcc = GetOccFromRef(spOccContext, ipiNavRef);
		if (NULL_var == spCurOcc)
		{
			cout << "#  === FAILED ===> GetOccFromRef" << endl;
			return rc;
		}
		else
		{
			cout << "#  === OK ===> GetOccFromRef" << endl;
			// 比较 成熟度（current）、owner 参数
			bool isInWork = IfMaturityInWork(ipiNavRef);
			bool isOwner = IfOwnerRight(ipiNavRef);
			cout << CUSCAAUtilService::GetAliasName(ipiNavRef);
			if (!isInWork)
				cout<< "	成熟度（current） 【不符合】	";
			if (!isOwner)
				cout << "	所有者（owner） 【不符合】	";
			if (isInWork && isOwner)
			{
				cout << "	成熟度（current） 【符合】; 所有者（owner） 【符合】	";
				oNavOccChild.Append(spCurOcc);
			}
			cout << endl;
		}
	}
	// ===========================================================================================================
	// 4-1	: Seek the Part Instances aggregated under the Current Reference
	// ===========================================================================================================
	coreType = PLMCoreInstance;
	rc = ipiNavRef->ListChildren(childrenList, 1, &coreType);
	if (SUCCEEDED(rc))
	{
		for (int i = 0; i < iDepth; i++)
			cout << "	";
		cout << "the size of the instances aggregated under Ref is " << childrenList.Size() << endl;

		// ===========================================================================================================
		// 4-2	: For each Part Instances
		// ===========================================================================================================
		int j = 1;
		while (SUCCEEDED(rc) && (j <= childrenList.Size()))
		{
			CATIPLMNavEntity* piNavEntity = childrenList[j];
			if (NULL != piNavEntity)
			{
				// ===========================================================================================================
				// 4-2-0	: Print instance attributes
				// ===========================================================================================================
				//hr = PrintPLMComponent(piNavEntity, iAllAtributes, iDepth + 1);			// 打印当前 Instance' 的属性 externalID
				//if (S_OK == hr)
				//{
				// ===========================================================================================================
				// 4-2-1	: Seek the Part Reference corresponding to the current Part Instance
				// ===========================================================================================================

				// Seek the CATIPLMNavInstance* from CATIPLMNavEntity*
				CATIPLMNavInstance* piNavInst = NULL;
				rc = piNavEntity->QueryInterface(IID_CATIPLMNavInstance, (void **)&piNavInst);
				if (SUCCEEDED(rc))
				{
					// Retrieve the reference of the instance 
					CATIPLMNavReference* piNavRef1 = NULL;
					rc = piNavInst->GetReferenceInstanceOf(piNavRef1);	//搜索后的 层级：rootref - inst- ref -rep isnt -repref
					if (SUCCEEDED(rc) && (NULL != piNavRef1))
					{
						// ===========================================================================================================
						// 4-2-2	: Recursive call to BrowseReference with each of those Part References
						// ===========================================================================================================
						rc = BrowseReference(piNavRef1, iRootProcessOcc, iDepth + 1 + 1, oNavOccChild);

						if (SUCCEEDED(rc))
						{
							// Release piNavRef1 pointer
							if (NULL != piNavRef1)
							{
								piNavRef1->Release();
								piNavRef1 = NULL;
							}
						}
					}
					piNavInst->Release();
					piNavInst = NULL;

					//}
				}
				// ===========================================================================================================
				// 4-2-3	: Release the pointer in the childrenList
				// ===========================================================================================================
				piNavEntity->Release();
				piNavEntity = NULL;

			}
			j++;

		}// while loop ends				
		childrenList.RemoveAll();
	}

	return rc;
}

// fengy 2021.11.30 DELIPPRProcessOutputComputeAuth ::ComputeProcessOutput 
HRESULT ComacComputeReslutingProductCmd::ComputeResultingProduct(CATListPtrCATIPLMNavOccurrence listCreateAssmOcc)
{
	HRESULT rc = E_FAIL;
	int size = listCreateAssmOcc.Size();
	if (size == 0)
	{
		cout << "ComputeResultingProduct listCreateAssmOcc 输入为空！ \n." << endl;
		return rc;																		// 返回1 表示KO！
	}

	DELIPPRProcessAuth_var hPPRProcessAuth;
	rc = ::GetPPRProcessAuth(hPPRProcessAuth);
	_RETURN_IF_FAILED_(rc, "::GetPPRProcessAuth");
	if (!hPPRProcessAuth)
	{
		cout << "=== FAILED ===> GetPPRProcessAuth\n." << endl;
		return rc;																		// 返回1 表示KO！
	}
	cout << "=== OK ===> GetPPRProcessAuth" << endl;

	DELIPPRProcessOutputComputeAuth_var hPPRProcessOutputComputeAuth(hPPRProcessAuth);		// Auth 转换
	if (NULL_var == hPPRProcessOutputComputeAuth)
	{
		cout << "=== FAILED ===> hPPRProcessOutputComputeAuth" << endl;
		return rc;
	}
	cout << "=== OK ===> hPPRProcessOutputComputeAuth" << endl;

	for (int i = size; i >= 1; i--)
		//for (int i = 1; i <= size; i++)
	{
		CATIPLMNavOccurrence* ipiProcessOcc = listCreateAssmOcc[i];
		//if (NULL == ipiProcessOcc)
		//{
		//	cout <<"# "<< i << "=== FAILED ===> QI listCreateAssmOcc[i]" << endl;
		//	return rc;
		//}
		//cout << "# " << i << "=== OK ===> QI listCreateAssmOcc[i]" << endl;

		//Comput ProcessOutput
		//-------------------------------
		CATIPLMNavReference* opProcessOutputRef;
		rc = hPPRProcessOutputComputeAuth->ComputeProcessOutput(ipiProcessOcc, opProcessOutputRef);		// 计算当前的 Occ

		if (FAILED(rc) || (NULL == opProcessOutputRef))
		{
			cout << "# " << i << "=== FAILED ===> ComputeProcessOutput :   " << CUSCAAUtilService::GetAliasName(ipiProcessOcc) << endl;
			//return rc;
		}
		else
			cout << "# " << i << "=== OK ===> ComputeProcessOutput:   " << CUSCAAUtilService::GetAliasName(ipiProcessOcc) << endl;
	}
	return S_OK;
}

// rootref - rootOcc
HRESULT ComacComputeReslutingProductCmd::GetOccurrenceFromProcessReference(const CATIPLMNavReference_var & ihNavRef, CATIPLMNavOccurrence_var & ohNavOcc)
{
	DELIPPRProcessOccAuth* pProcessAuthService = getDELIPPRProcessOccAuth();
	DELIPPRProcessOccAuth_var hProcessOccAuth(pProcessAuthService);
	ReleasePtr(pProcessAuthService);
	if (hProcessOccAuth == NULL_var) return E_FAIL;

	CATIPLMNavOccurrence * pNavOcc = NULL;
	HRESULT rc = hProcessOccAuth->GetOrCreateRootOccurrence(ihNavRef, pNavOcc);
	ohNavOcc = pNavOcc;
	ReleasePtr(pNavOcc);
	return rc;
}

void ComacComputeReslutingProductCmd::ReleasePtr(CATBaseUnknown * piCBU)
{
	if (NULL != piCBU)
	{
		piCBU->Release();
		piCBU = NULL;
	}
}

// fengy 2021.12.1 
CATUnicodeString  ComacComputeReslutingProductCmd::GetKnowledgeType(CATIPLMNavReference* piNavEnt, int iDepth)
{
	CATUnicodeString sRefType = CUSCAAUtilService::GetObjectKnowledgeType(piNavEnt);
	for (int j = 0; j < iDepth; j++)
		cout << "	";
	cout << " " << sRefType << endl;
	return sRefType;
}


// 
bool ComacComputeReslutingProductCmd::IfMaturityInWork(CATIPLMNavReference *ipiNavRef)
{
	bool isInWork = false;
	if (ipiNavRef == NULL)
	{
		cout << "  IfMaturityInWork 输入为空！"  << endl;
		return isInWork;
	}
	CATUnicodeString sMaturity = CUSCAAUtilService::GetObjectAttrValue(ipiNavRef, "current");
	cout << "#Maturity STATUS: " << sMaturity << endl;
	if (CATUnicodeString("IN_WORK") == sMaturity)
		return true;

	return isInWork;
}

bool ComacComputeReslutingProductCmd::IfOwnerRight(CATIPLMNavReference *ipiNavRef)
{
	bool isOwner = false;
	if (ipiNavRef == NULL)
	{
		cout << "  IfOwnerRight 输入为空！" << endl;
		return isOwner;
	}
	CATUnicodeString sOwner = CUSCAAUtilService::GetObjectAttrValue(ipiNavRef, "owner");
	cout << "#当前 所有者owner: " << sOwner << endl;

	CATString oUserId, oOrganisationId, oProjectId, oRoleId;
	CATAdpPublicSecurityServices::GetSecurityParameters("", oUserId, oOrganisationId, oProjectId, oRoleId);
	cout << "#GetSecurityParameters: " << oUserId << endl << oOrganisationId << endl << oProjectId << endl << oRoleId << endl;

	if (oUserId == sOwner)
		return true;


	return isOwner;

}