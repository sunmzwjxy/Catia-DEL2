//===================================================================
// COPYRIGHT comac 2021/03/30
//===================================================================
// fengyHelper.cpp
// Header definition of class fengyHelper
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2021/03/30 Creation: Code generated by the 3DS wizard
//===================================================================

#include "fengyHelper.h"
#include "CUSCAAUtilService.h"

// System
#include "CATInstantiateComponent.h"

//SpecialAPI Typedef CATBoolean
#include "CATSysBoolean.h"

//System Global Function CATFOpen
#include "CATStdIO.h"

//CATPLMIntegrationAccess class 
#include "CATAdpAttributeSet.h"
#include "CATAdpQueryResult.h"
#include "CATLISTP_CATAdpQueryResult.h"
#include "CATIAdpPLMIdentificator.h"

//CATPLMIdentificationAccess Interface 
#include "CATIPLMComponent.h"

//PLMDictionaryNavServices class 
#include "CATCkePLMNavPublicServices.h"

//KnowledgeInterfaces Interface 
#include "CATIType.h"

//CATPLMIntegrationUse class 
#include "CATAdpPLMQueryServices.h"
#include "CATAdpOpener.h"

//CATPLMUIInterfaces Interface 
#include "CATIPLMOpenServices.h"
#include "CATPLMOpenServicesFactory.h"

// CATPLMComponentInterfaces Framework
#include "CATIPLMNavOccurrence.h"
#include "CATIPLMNavReference.h"
#include "CATIPLMNavInstance.h"
#include "CATIPLMNavEntity.h"
#include "CATIPLMNavRepInstance.h"
#include "CATListPtrCATIPLMNavEntity.h"
#include "CATPLMComponentInterfacesServices.h"
#include "CATIPLMComponent.h"
#include "CATListPtrCATIPLMComponent.h"
#include "CATIPLMIdentifierSet.h"

// CAT3DPhysicalRepInterfaces 
#include "CATIPsiRepresentationReference.h"
#include "CATIPsiRepresentationLoadMode.h"

// CATPLMIdentificationAccess Framework: 
#include "CATIAdpType.h"


//ObjectModelerSystem Interface 
#include "CATIAlias.h"

//CATMecModLiveUseItf Interface 
#include "CATIPartRequest.h"

//CATMecModUseItf Interface 
#include "CATIMmiPrtContainer.h"
#include "CATIMmiUseSetFactory.h"
#include "CATIMmiUseDatumFactory.h"
#include "CATIMmiUseGeometricalElement.h"

//CATMecModUIUseItf class 
#include "CATFeatureImportAgent.h"
//CATMecModUseItf Interface 
#include "CATIMfZeroDimResult.h"
#include "CATIMfMonoDimResult.h"
#include "CATIMfBiDimResult.h"

//CATGSMUseItf Interface 
#include "CATIGSMUseProceduralView.h"

//DataCommonProtocolUse class 
#include "DataCommonProtocolServices.h"
#include "CATIUseEntity.h"

//AfrFoundation class 
#include "CATApplicationFrame.h"
#include "CATFrmEditor.h"

//Dialog class
#include "CATDlgNotify.h"

//KnowledgeInterfaces Interface 
#include "CATICkeObject.h"
#include "CATCkeObjectAttrReadServices.h"
#include "CATCkeObjectAttrWriteServices.h"
#include "CATICkeParameterSet.h"
#include "CATIParmPublisher.h"
#include "CATIKweModelServices.h"
#include "CATICkeRelationForwards.h"
#include "CATCkeGlobalFunctions.h"

//KnowledgeIDLItf
#include "CATIAParameter.h"
#include "CATIAParameters.h"
#include "CATIAParameterSet.h"

//System BuildVariant()在这定义
#include "CATAutoConversions.h"

// VisualizationInterfaces 
#include "CATIVisProperties.h"
#include "CATVisPropertiesValues.h"

//time
#include "CATTimeSpan.h"
#include "CATTime.h"

//// ExcelRW.h 较繁琐；需要CString CATUnicodeString的 转换！ClsOfExcelOperation OK！
//#include "ExcelRW.h"
//#include "ClsOfExcelOperation.h"

//CreateClashSimulation
#include "PLMIInterferenceServices.h"
#include "PLMIInterferenceSimulation.h"
#include "CATAdpSaver.h"
#include "CATListPtrPLMIInterferenceResult.h"
#include "PLMIInterferenceResult.h"

// GMModelInterfaces Framework: 
#include "CATBody.h"

#include "iostream.h"

// _access 创建文件path
#include <io.h>
#include <direct.h>

// UpdateObject
#include "CATPrtUpdateCom.h"
#include "CATIMmiMechanicalFeature.h"
#include "CATIRedrawEvent.h"
#include "CATIModelEvents.h"

// CATVisItf
#include "CATModify.h"

// PLMSetupDataInterfaces
#include "PLMISetupDataFinder.h"
#include "PLMSetupDataGlobalFunctions.h"

// SearchPrdByTitle()
#include "CATAdpOpenParameters.h"
// GetObjectType()
#include "CATPLMTypeServices.h"
// SaveAs()
#include "CATAdpDuplicator.h"
#include "CATIAdpPLMErrorReviewer.h"
// GetAdpPLMID()
#include "CATAdpIdentificationSet.h"

#include "CATIPrdObject.h"

// GetFeatureFromSelect()
#include "CATIMmiUseFeaturize.h"
#include "CATIMmiUseMfBRep.h"


#define  MAX_ROW 999999


using namespace std;
//-----------------------------------------------------------------------------
// fengyHelper : constructor
//-----------------------------------------------------------------------------
fengyHelper::fengyHelper()
{
	//rc = E_FAIL;
	//
	//TODO: Add the constructor code here
	//
}

//-----------------------------------------------------------------------------
// fengyHelper : destructor
//-----------------------------------------------------------------------------

fengyHelper::~fengyHelper()
{
	//
	// TODO: Place code here.
	//
}


void fengyHelper::Notify(CATUnicodeString iMsg,
	CATUnicodeString iTitle)
{
	CATDlgNotify* piNotifyDlg = new CATDlgNotify((CATApplicationFrame::GetFrame())->GetMainWindow(), "Unauthorized Access", CATDlgNfyOK);
	if (NULL != piNotifyDlg)
	{
		cout << "Notify OK！" << endl;
		piNotifyDlg->DisplayBlocked(iMsg, iTitle);

	}
	//cout << "  dlg GetText:" << piNotifyDlg->GetText()<< endl;

	return;
}


void fengyHelper::NotifyWithStyle(CATUnicodeString Msg,
	CATUnicodeString DlgTitle,
	CATDlgStyle iStyle)
{
	CATApplicationFrame *pApplication = CATApplicationFrame::GetFrame();
	if (NULL != pApplication)
	{
		CATDlgWindow * pMainWindow = pApplication->GetMainWindow();
		if (NULL != pMainWindow)
		{
			CATDlgNotify *pNotifyDlg = new CATDlgNotify(pMainWindow, "CAANotifyDialog", iStyle);
			if (NULL != pNotifyDlg)
			{
				pNotifyDlg->DisplayBlocked(Msg, DlgTitle);
				pNotifyDlg->RequestDelayedDestruction();
			}
			else
			{
				cout << "Failed to instantiate the Notify dialog" << endl;
			}
		}
		else
		{
			cout << "Main window retrieval from application frame failure" << endl;
		}
	}
	else
	{
		cout << "Failure to retrieve Application Frame" << endl;
	}
	return;
}

// 等待提示按钮的 确认回调函数  2021.4.7 fengy
void fengyHelper::NotifyWithOpen(CATUnicodeString iMessage, CATUnicodeString ifilePath, CATDlgStyle iStyle)
{
	CATApplicationFrame * pApplication = CATApplicationFrame::GetFrame();
	if (NULL != pApplication)
	{
		CATDlgNotify * pNotifyDlg = new CATDlgNotify(pApplication->GetMainWindow(),
			"一键打开 log 文档", iStyle);

		if (NULL != pNotifyDlg)
		{
			//CATUnicodeString tmp= pNotifyDlg->GetText();
			//tmp.Append("124567");
			//Notify(tmp);
			iMessage.Append("\n===============\n 打开该文件吗？");
			int i_press = pNotifyDlg->DisplayBlocked(iMessage, "一键打开 log 文档");		//最后按这个标题

			if (i_press == 1)
			{
				//AddAnalyseNotificationCB(this, this->GetDiaOKNotification(), (CATCommandMethod)&CAAAfrProgressTaskSampleCmd::OpenTXT, NULL);	
				//AddAnalyseNotificationCB(pNotifyDlg, pNotifyDlg->GetNfyOKNotification(), (CATCommandMethod)&CAAAfrProgressTaskSampleCmd::OpenTXT, NULL);
				pNotifyDlg->SetVisibility(CATDlgHide);

				//OpenTXT(logFilePath);
				HINSTANCE hi = ShellExecute(NULL, _T("open"), ifilePath, NULL, NULL, SW_SHOWNORMAL);
			}
			if (i_press != 1)
			{
				pNotifyDlg->SetVisibility(CATDlgHide);
			}
			//pNotifyDlg->RequestDelayedDestruction();			//  不要直接摧毁
		}
	}
	return;
}

// 2021.12.22  fengy   Notify 提醒继续与否！
void fengyHelper::NotifyYesOrNO(CATString isTitle, CATUnicodeString iMessage, bool & oToContinue, CATDlgStyle iStyle)
{
	oToContinue = false;		// 不继续运行
	CATApplicationFrame * pApplication = CATApplicationFrame::GetFrame();
	if (NULL != pApplication)
	{
		CATDlgNotify * pNotifyDlg = new CATDlgNotify(pApplication->GetMainWindow(), isTitle, iStyle);

		if (NULL != pNotifyDlg)
		{
			
			int i_press = pNotifyDlg->DisplayBlocked(iMessage, isTitle.CastToCharPtr());		//最后按这个标题

			if (i_press == 1)
			{
				pNotifyDlg->SetVisibility(CATDlgHide);

				oToContinue = true;		// 继续运行

			}
			if (i_press != 1)
			{
				pNotifyDlg->SetVisibility(CATDlgHide);
				oToContinue = false;		// 不继续运行

			}
			//pNotifyDlg->RequestDelayedDestruction();			//  不要直接摧毁
		}
	}
	return;
}

//  GetObjTitle 的 结果：PD_229A7009-812-001.1
// 测试出：暂时对应 instance name
void fengyHelper::GetObjTitle(CATBaseUnknown * ipBaseUnknown, CATUnicodeString & ioAliasString)
{
	CATIAlias_var spAlias = ipBaseUnknown;
	ioAliasString = spAlias->GetAlias();
	//cout << " ipBaseUnknown 的 FeatureName： " << ioAliasString << endl;

	return;
}

//写 instance name 失败！、写入TitleKO！
void fengyHelper::SetObjTitle(CATBaseUnknown_var ispObj, CATUnicodeString usTitle)
{
	CATIAlias_var spAlias = ispObj;
	if (!!spAlias)
	{
		spAlias->SetAlias(usTitle);
	}
}

// 组合 external_ID
//  GetAttrVlaueFromOcc pippipe-comac-00000635// 获取 external_ID等属性
CATUnicodeString fengyHelper::GetAttrVlaueFromOcc(CATIPLMNavOccurrence_var ispOcc, CATUnicodeString  ikey)
{
	CATUnicodeString usValue;

	HRESULT rc = CATCkeObjectAttrReadServices::GetValueAsString(GetInsFromOcc(ispOcc), ikey, usValue);
	cout << "usValue： " << usValue << endl;

	if (FAILED(rc))
	{
		cout << "GetAttrVlaueFromOcc 执行 KO！ " << endl;
		return "";
	}
	return usValue;
}

//GetInsFromOcc
CATIPLMNavInstance_var fengyHelper::GetInsFromOcc(CATIPLMNavOccurrence_var spOcc)
{
	if (spOcc == NULL_var)
		return NULL_var;
	//cout<< "GetInsFromOcc spOcc 存在！"<<endl;

	CATIPLMNavInstance * pIns = NULL;
	spOcc->GetRelatedInstance(pIns);
	CATIPLMNavInstance_var spIns = pIns;

	if (NULL_var == spIns)
		cout << "GetInsFromOcc 返回为空！" << endl;
	return spIns;
}

//  SetAttrVlaueFromOcc  
HRESULT fengyHelper::SetAttrVlaueFromOcc(CATUnicodeString iusValue, CATIPLMNavOccurrence_var ispOcc, CATUnicodeString  ikey)
{
	HRESULT rc = E_FAIL;
	if (CATUnicodeString("") == iusValue)
	{
		cout << "输入的iusValue 为空！ " << endl;
		return rc;
	}
	rc = CATCkeObjectAttrWriteServices::SetValueWithString(GetInsFromOcc(ispOcc), ikey, iusValue);
	if (FAILED(rc))
		cout << "SetValueWithString 执行KO！ " << endl;

	return rc;
}

// 法二：
HRESULT fengyHelper::GetPLMComponentAttr(CATIPLMNavEntity* ipiNavEntity, CATListOfCATUnicodeString & oAttrNameList, CATListOfCATUnicodeString & oAttrValueList)
{
	HRESULT rc = E_FAIL;
	if (NULL == ipiNavEntity) return E_INVALIDARG;
	oAttrNameList.Append("V_Name");
	oAttrNameList.Append("PLM_ExternalID");
	oAttrNameList.Append("majorrevision");

	rc = ipiNavEntity->GetPublicAttributes(oAttrNameList, oAttrValueList);
	cout << "GetPLMComponentAttr: " << endl;
	cout << "		V_Name: " << oAttrValueList[1] << endl;
	cout << "		PLM_ExternalID: " << oAttrValueList[2] << endl;
	cout << "		majorrevision: " << oAttrValueList[3] << endl;
	return rc;
}
// 4种 针对性获取属性页上 Title的api：InsTitle（FromOcc）、RefTitle（FromOcc）

CATUnicodeString fengyHelper::GetInsTitle(CATIPLMNavInstance_var ispIns)
{
	if (NULL_var == ispIns) return "";

	CATUnicodeString usValue;
	CATCkeObjectAttrReadServices::GetValueAsString(ispIns, "PLM_ExternalID", usValue);
	return usValue;
}

CATUnicodeString fengyHelper::GetInsTitleFromOcc(CATIPLMNavOccurrence_var ispOcc)
{
	CATUnicodeString usValue;
	CATCkeObjectAttrReadServices::GetValueAsString(GetInsFromOcc(ispOcc), "PLM_ExternalID", usValue);
	return usValue;
}

CATUnicodeString fengyHelper::GetRefTitle(CATIPLMNavReference_var ispRef)
{
	if (NULL_var == ispRef) return "";

	CATUnicodeString usRefTitle;
	CATCkeObjectAttrReadServices::GetValueAsString(ispRef, "V_Name", usRefTitle);
	return usRefTitle;
}

CATUnicodeString fengyHelper::GetRefTitleFromOcc(CATIPLMNavOccurrence_var ispOcc)
{
	CATUnicodeString usRefTitle;
	CATCkeObjectAttrReadServices::GetValueAsString(GetRefFromOcc(ispOcc), "V_Name", usRefTitle);
	return usRefTitle;
}

//JD 组合
//GetRefIdFromOcc
CATUnicodeString fengyHelper::GetRefIdFromOcc(CATIPLMNavOccurrence_var spOcc)
{
	return GetRefID(GetRefFromOcc(spOcc));
}
//获取RefID号
CATUnicodeString fengyHelper::GetRefID(const CATIPLMNavReference_var& spRef)
{
	CATUnicodeString usID;
	CATICkeObject_var spCkeObj = spRef;
	if (spCkeObj != NULL_var)
		CATCkeObjectAttrReadServices::GetValueAsString(spCkeObj, "PLM_ExternalID", usID);

	return usID;
}
//由Occ获取Ref，注意返回值的临时性！！
CATIPLMNavReference_var fengyHelper::GetRefFromOcc(CATIPLMNavOccurrence_var spOcc)
{
	if (!spOcc) return NULL_var;

	CATIPLMNavReference_var spRef;
	if (NULL_var != spOcc)
	{
		CATIPLMNavReference*pRef = NULL;
		spOcc->GetRelatedReference(pRef);
		spRef = pRef;
		pRef->Release(); pRef = NULL;
	}
	return spRef;
}

HRESULT fengyHelper::CreateTool(CATIMmiUsePrtPart_var spPrtPart, CATIGSMTool_var & iospGsmTool, CATUnicodeString iToolName)
{
	HRESULT rc = E_FAIL;

	CATIMmiMechanicalFeature_var spMechFeatOnMainTool = spPrtPart;
	if (NULL_var == spMechFeatOnMainTool)
	{
		return rc;
	}
	CATIMmiPrtContainer_var spPrtCont = NULL_var;
	rc = spMechFeatOnMainTool->GetPrtContainer(spPrtCont);
	if (FAILED(rc) || NULL_var == spPrtCont)
	{
		return rc;
	}

	CATIMmiUseSetFactory_var spMechanicalRootFactory = spPrtCont;
	if (NULL_var == spMechanicalRootFactory)
	{
		return E_FAIL;
	}

	CATIMmiMechanicalFeature_var spGSMTool;
	rc = spMechanicalRootFactory->CreateGeometricalSet(iToolName, spMechFeatOnMainTool, spGSMTool);
	if (FAILED(rc) || NULL_var == spGSMTool)
	{
		return rc;
	}

	iospGsmTool = spGSMTool;

	return rc;
}

HRESULT fengyHelper::AppendContentToFile(CATUnicodeString strFilePath, CATUnicodeString strContent)
{
	HRESULT hr = S_OK;

	unsigned int uFile = 0;
	hr = ::CATFOpen(&strFilePath, "ab+", &uFile);		// 指针指向文件 尾部
	if (FAILED(hr))
	{
		cout << "*** Error : Open log file " << strFilePath.ConvertToChar() << " failed" << endl;
		return E_FAIL;
	}

	CATUnicodeString strWrite = strContent + "\n";

	int nWritten = 0;
	::CATFPuts(strWrite, uFile, &nWritten);
	::CATFClose(uFile);

	return S_OK;
}

// 获取根节点对应的CATIPLMNavReference_var
HRESULT fengyHelper::GetRootReference(CATIPLMNavReference_var & iospRootReference)
{
	CATListPtrCATIPLMComponent oRootList;
	HRESULT rc = E_FAIL;
	rc = CATPLMComponentInterfacesServices::GetEditedRootPLMComponents(CATFrmEditor::GetCurrentEditor(), oRootList);
	if (FAILED(rc) || 0 == oRootList.Size())
	{
		cout << "InsertPredecessor KO" << endl;
		return rc;
	}

	iospRootReference = oRootList[1];
	return rc;
}

// 组合 - from JD
//获取RootOcc
CATIPLMNavOccurrence_var fengyHelper::GetRootOcc()
{
	CATIPLMNavOccurrence_var spRootOcc;
	CATFrmEditor * pFrmEditor = CATFrmEditor::GetCurrentEditor();
	CATIPLMNavOccurrence_var spOccOnCurrent = NULL_var;
	GetCurrentActiveOcc(pFrmEditor, spOccOnCurrent);
	CATIPrdObject_var spPrdObj = spOccOnCurrent;
	if (NULL_var != spPrdObj)
	{
		CATBaseUnknown*pBaseOnRoot = NULL;
		spPrdObj->GetRootFather(pBaseOnRoot);
		spRootOcc = pBaseOnRoot;
	}
	else
	{
		while (NULL_var != spOccOnCurrent)		// 不太明白！
		{
			spRootOcc = spOccOnCurrent;
			spOccOnCurrent = GetFartherOcc(spOccOnCurrent);
		}
	}
	return spRootOcc;
}
void fengyHelper::GetCurrentActiveOcc(CATFrmEditor* ipEditor, CATIPLMNavOccurrence_var& oSpiNavOccurrence)
{
	HRESULT rc;
	CATPathElement pUIElem = ipEditor->GetUIActiveObject();
	CATIPLMNavOccurrence *piActiveNavOccurrence = NULL;
	rc = pUIElem.Search(IID_CATIPLMNavOccurrence, (void**)&piActiveNavOccurrence);
	if (piActiveNavOccurrence == NULL)
	{
		std::cout << "未激活正确装配，请重新激活" << std::endl;
		return;
	}
	oSpiNavOccurrence = piActiveNavOccurrence;
	if (NULL != piActiveNavOccurrence)
	{
		piActiveNavOccurrence->Release();
		piActiveNavOccurrence = NULL;
	}
}
//GetFartherOcc
CATIPLMNavOccurrence_var fengyHelper::GetFartherOcc(CATIPLMNavOccurrence_var spOcc)
{
	if (NULL_var == spOcc)
		return NULL_var;

	CATIPLMNavOccurrence*pFartherOcc = NULL;
	spOcc->GetFather(pFartherOcc);
	CATIPLMNavOccurrence_var spFartherOcc = pFartherOcc;
	if (NULL != pFartherOcc) { pFartherOcc->Release(); pFartherOcc = NULL; }

	return spFartherOcc;
}

// JD- 获取所有子件
CATBoolean fengyHelper::GetAllChildren(CATIPLMNavOccurrence_var spSelectNode, CATLISTV(CATBaseUnknown_var) &listAllChildren, CATBoolean bRecursive)
{
	if (NULL_var == spSelectNode)	return FALSE;
	HRESULT rc = E_INVALIDARG;

	CATListPtrCATIPLMNavOccurrence listChildren;
	rc = spSelectNode->ListChildren(listChildren);

	for (int i = 1; i <= listChildren.Size(); i++)
	{
		listAllChildren.Append(listChildren[i]);

		if (bRecursive)
			GetAllChildren(listChildren[i], listAllChildren, bRecursive);
	}

	if (listAllChildren.Size() == 0)	return FALSE;
	return TRUE;
}

// 显示/隐藏特征
HRESULT fengyHelper::ShowOrHideFeature(CATBaseUnknown_var ispFeature, CATBoolean iShow)
{
	CATIVisProperties_var spVisProperties = ispFeature;
	if (NULL_var == spVisProperties)
	{
		cout << "Change CATIMmiMechanicalFeature_var to CATIVisProperties_var KO" << endl;
		return E_FAIL;
	}

	CATVisPropertiesValues VisPropValues;
	if (iShow)
		VisPropValues.SetShowAttr(CATShowAttr);
	else
		VisPropValues.SetShowAttr(CATNoShowAttr);

	spVisProperties->SetPropertiesAtt(VisPropValues, CATVPShow, CATVPGlobalType);

	return S_OK;
}

void fengyHelper::UpdateFeature(CATBaseUnknown_var spObj)
{
	CATIUseEntity_var spUseEntity = spObj;
	if (NULL_var != spUseEntity)
	{
		DataCommonProtocolServices::Update(spUseEntity);
	}
}

HRESULT fengyHelper::UpdateFeature(CATIMmiMechanicalFeature_var ispMmiMechanicalFeature, CATBoolean IfInsertInProceduralView)
{
	HRESULT rc = E_FAIL;
	if (IfInsertInProceduralView)
	{
		CATIGSMUseProceduralView_var spProceduralView = ispMmiMechanicalFeature;
		if (NULL_var == spProceduralView)
		{
			cout << " UpdateFeature KO 1" << endl;
			return rc;
		}
		rc = spProceduralView->InsertInProceduralView();
		if (FAILED(rc))
		{
			cout << " UpdateFeature KO 2" << endl;
			return rc;
		}
	}

	CATIUseEntity_var hUseEnt(ispMmiMechanicalFeature);
	if (NULL_var == hUseEnt)
	{
		cout << " UpdateFeature KO 3" << endl;
		return E_FAIL;
	}

	rc = DataCommonProtocolServices::Update(hUseEnt);
	if (FAILED(rc))
	{
		cout << " UpdateFeature KO 4" << endl;
		return rc;
	}
	return rc;
}

// UpdateObject ――貌似KO 2021.5.25
void fengyHelper::UpdateObject(CATBaseUnknown_var ispUKObject)
{
	// 更新特征
	CATPrtUpdateCom* pPrtUpdateCom = new CATPrtUpdateCom(ispUKObject/*, 1, 1*/);
	if (NULL == pPrtUpdateCom)
	{
		cout << " UpdateObject KO 1" << endl;
		return;
	}

	// 刷新特征树
	CATIRedrawEvent_var spiRedrawEvent = ispUKObject;
	if (NULL_var != spiRedrawEvent)
	{
		spiRedrawEvent->Redraw();
	}

	// 刷新三维工作区
	CATModify pModify(ispUKObject);
	CATIModelEvents_var spiModelEvents(ispUKObject);
	if (NULL_var != spiModelEvents)
	{
		spiModelEvents->Dispatch(pModify);
	}
}

HMODULE fengyHelper::GetCurrentModuleHandle()
{
	MEMORY_BASIC_INFORMATION mbi;
	::VirtualQuery((LPVOID)GetCurrentModuleHandle, &mbi, sizeof(mbi));
	return (HMODULE)mbi.AllocationBase;
}


HRESULT  fengyHelper::GetCurrentDLLPath(CATUnicodeString & ostrDLLPath)
{
	char chCurrentWorkDirectory[1024] = { 0 };			//current dll path;
	GetModuleFileNameA(GetCurrentModuleHandle(), chCurrentWorkDirectory, 1024);
	if ('\0' == chCurrentWorkDirectory)
		return E_FAIL;

	ostrDLLPath = chCurrentWorkDirectory;

	int nKeyWordsPosition = 0;
	nKeyWordsPosition = ostrDLLPath.SearchSubString(CATUnicodeString("\\"), 0, CATUnicodeString::CATSearchModeBackward);
	if (-1 == nKeyWordsPosition)
		return E_FAIL;

	ostrDLLPath.Remove(nKeyWordsPosition + 1, ostrDLLPath.GetLengthInChar() - nKeyWordsPosition - 1);
	return S_OK;
}

HRESULT  fengyHelper::CreateDir(CATUnicodeString & istrDir)
{
	if ("" == istrDir)
		return E_FAIL;

	const char * pstrPrefix = istrDir.ConvertToChar();

	if (_access(pstrPrefix, 0) == -1)	//如果文件夹不存在
	{
		_mkdir(pstrPrefix);				//则创建
		cout << "目录创建 ok：" << istrDir.ConvertToChar() << endl;
		return S_OK;
	}
	else
	{
		cout << "目录已存在，无需创建！" << istrDir.ConvertToChar() << endl;
		return S_OK;
	}

}
void  fengyHelper::GetCurrentTimeStr(CATUnicodeString &ologTime)
{
	CATTime logTime = CATTime::GetCurrentLocalTime();
	ologTime = logTime.ConvertToString("%Y-%m-%d_%H：%M：%S");		      	// 月-日 时分秒格式
	return;
}

// 添加数字后缀！用于保存文件时 命名etc
CATUnicodeString fengyHelper::AddSuffix(int i)
{
	CATUnicodeString nbStr, ostrSuffix;
	nbStr.BuildFromNum(i);
	ostrSuffix.Append("_");
	ostrSuffix.Append(nbStr);
	cout << "ostrSuffix：" << ostrSuffix << endl;

	return ostrSuffix;

}
HRESULT  fengyHelper::CreateClashSimulation(CATIPLMNavReference_var  & ispRootReference,
	CATUnicodeString & ioSimuNameStr,
	PLMIInterferenceSimulation *& opiItfSimu,
	double  iClearanceValue)
{
	HRESULT rc = E_FAIL;
	if (NULL_var == ispRootReference || "" == ioSimuNameStr)
	{
		return rc;
	}
	cout << "传入的 ioSimuNameStr:		" << ioSimuNameStr << endl;

	//CATUnicodeString	curTime;
	//fengyHelper::GetCurrentTimeStr(curTime);
	//cout << "curTime:		" << curTime << endl;
	//ioSimuNameStr.Append("_");
	//ioSimuNameStr.Append(curTime);

	cout << "AtLast ：ioSimuNameStr:		" << ioSimuNameStr << endl;
	// 5.2/ Retrieve Interference Services
	PLMIInterferenceServices * piItfServices = NULL;
	rc = ::CATInstantiateComponent("PLMInterferenceServices", IID_PLMIInterferenceServices, (void**)& piItfServices);
	if (FAILED(rc) || (NULL == piItfServices))
	{
		cout << "ERROR Retrieving Interference Services " << endl;
		return rc;
	}

	CATListPtrCATBaseUnknown       ListPtrSaveRoot;			// 用于保存 simla？
	CATAdpSaver                    Saver;
	// 5.3/ Create a default Simulation upon the Product Root
	opiItfSimu = NULL;
	if (NULL_var != ispRootReference)
	{
		cout << "Begin     CreateInterferenceSimulation   " << endl;
		rc = piItfServices->CreateInterferenceSimulation(ispRootReference, opiItfSimu);
		if (FAILED(rc) || opiItfSimu == NULL)
		{
			cout << "   ERROR Creating Interference Simulation    " << endl;
			return rc;
		}
		else
		{
			CATUnicodeString newString;
			for (int i = 1; i <= MAX_ROW; i++)		// 至多保存 10w 份 同一个id下的
			{
				CATUnicodeString tmpString = ioSimuNameStr;
				if (i != 1)
				{
					//newString.BuildFromNum(i - 1);
					//tmpString.Append("_");
					//tmpString.Append(newString);

					tmpString.Append(AddSuffix(i - 1));
				}
				cout << "tmpString :		" << tmpString << endl;

				CATICkeObject_var     spCkeObject(NULL_var);
				spCkeObject = (CATICkeObject_var)opiItfSimu;
				if (spCkeObject != NULL_var)
				{
					CATUnicodeString     AttriNameStr1("PLM_ExternalID"), AttriNameStr2("V_Name"), AttriNameStr3("name");
					CATCkeObjectAttrWriteServices::SetValueWithString(spCkeObject, AttriNameStr1, tmpString);
					CATCkeObjectAttrWriteServices::SetValueWithString(spCkeObject, AttriNameStr2, tmpString);
					CATCkeObjectAttrWriteServices::SetValueWithString(spCkeObject, AttriNameStr3, tmpString);
				}
				cout << "   SUCCEEDED Creating Interference Simulation    " << endl;

				// 11. Save the Simulation 
				ListPtrSaveRoot.Append(opiItfSimu);
				rc = Saver.Save(&ListPtrSaveRoot);
				if (FAILED(rc))
				{
					// The given simulation name must be unique because saving over a Simulation, is only possible if the existing Simulation is open
					cout << "   FAILED Unable to save simulation after CreateInterferenceSimulation  " << i << "次" << endl;
					continue;
				}
				else
				{
					ioSimuNameStr = tmpString;
					cout << "   SUCCEEDED Save Interference Simulation11111    " << i << "次" << endl;
					cout << "save ok 后的 ioSimuNameStr:" << ioSimuNameStr << endl;
					break;
				}
				if (i = MAX_ROW)
				{
					// The given simulation name must be unique because saving over a Simulation, is only possible if the existing Simulation is open
					cout << "   FAILED Unable to save simulation after CreateInterferenceSimulation  " << i << "次" << endl;
					Notify(ioSimuNameStr + "已超出最大保存次数，请重命名！或者删除掉平台上部分同名数模！");
					return rc;
				}

			}

		}
		//ispRootReference->Release();		// rootRef 释放
		//ispRootReference = NULL;
	}

	// 6. Set the Simulation Name
	//===========================
	if (NULL != opiItfSimu)
	{
		cout << "   NULL != opiItfSimu    " << endl;

		// AllAgainstAllInContext   
		PLMIInterferenceSimulation::GroupComputationType iComputationType1 = PLMIInterferenceSimulation::AllAgainstAllInContext;
		rc = opiItfSimu->SetGroupComputationType(iComputationType1);
		if (SUCCEEDED(rc))
		{
			// 11. Save the Simulation 
			rc = Saver.Save(&ListPtrSaveRoot);
			if (FAILED(rc))
			{
				// The given simulation name must be unique because saving over a Simulation, is only possible if the existing Simulation is open
				cout << "	FAILED Unable to save simulation after SetGroupComputationType \n  " << endl;
				return rc;
			}
			else
			{
				cout << "	Simulation successfully saved after SetGroupComputationType \n  " << endl;
			}
		}

		// 7. Set the Simulation SpecificationType to Clearance   //设置干涉类型
		//=================================================
		PLMIInterferenceSimulation::SpecificationType ItfSpecType = PLMIInterferenceSimulation::SpecStdClearance;
		rc = opiItfSimu->SetClearanceValue(iClearanceValue / 1000);
		if (rc == S_OK)
		{
			cout << "	Set clearance value Successfully   \n " << endl;
		}
		else
		{
			cout << "	FAILED to set clearance Value   \n " << endl;
		}
		// 7.2/ Check the current Simulation type is Clash
		rc = opiItfSimu->SetSpecificationType(ItfSpecType);
		if (rc == S_OK)
		{
			cout << "	Set Clearance SpecificationType Successfully   \n " << endl;
			PLMIInterferenceSimulation::SpecificationType ItfSpecType_Read = PLMIInterferenceSimulation::SpecStdNone;
			opiItfSimu->GetSpecificationType(ItfSpecType_Read);
			if ((rc == S_OK) && (ItfSpecType_Read == PLMIInterferenceSimulation::SpecStdClearance))
			{
				cout << "	Set Simulation SpecStdClearance Type Successfully  \n " << endl;
			}
			else if (rc != S_OK)
			{
				cout << "	FAILED to retrieve the Simulation Type  \n " << endl;
			}
			else
			{
				cout << "	The retrieved Simulation Specification Type is not Clearance \n " << endl;
			}
		}

		// 8. Simulation Launch
		//=====================
		// 8.1/ Execute the Simulation
		rc = opiItfSimu->Execute();
		if (rc == S_OK)
		{
			cout << " 22  Simulation Launch Successful    " << endl;
			fengyHelper::Notify(" Simulation Launch Successful！");
			//return rc;
		}
		else
		{
			// 8.2/ Save the Simulation
			//=========================
			rc = Saver.Save(&ListPtrSaveRoot);			// simula 强转
			if (FAILED(rc))
			{
				// The given simulation name must be unique because saving over a Simulation, is only possible if the existing Simulation is open
				cout << "FAILED Unable to save simulation after Execute \n  " << endl;
				return rc;
			}
			else
			{
				cout << "Simulation successfully saved after Execute \n  " << endl;
			}
			cout << " 22  FAILED Simulation Launch   " << endl;
			fengyHelper::Notify(" Simulation Launch KO！");

			return rc;
		}

		// 刷新结构树
		//rc = fengyHelper::UpdateFeature(ispRootReference ,true);		// 对象指定哪一个？
		//rc = fengyHelper::UpdateFeature(opiItfSimu, true);				
		//rc = fengyHelper::UpdateFeature(piItfServices, true);				// piItfServices
		//if (rc == S_OK)
		//{
		//	cout << "	UpdateFeature Successfully   \n " << endl;
		//}
		//else
		//{
		//	cout << "	UpdateFeature  KO \n " << endl;
		//}

		//fengyHelper::UpdateObject(ispRootReference);				// piItfServices
		////fengyHelper::UpdateObject(opiItfSimu);				// piItfServices
		////fengyHelper::UpdateObject(piItfServices);				// piItfServices

		//cout << "	UpdateObject  pass！ " << endl;
	}
	return S_OK;

}

//// 采用结构体 存储 clash result
//HRESULT fengyHelper::GetClashResult(PLMIInterferenceSimulation * ipiItfSimu, struct  CalshResultInfom       oResultInfo)

HRESULT fengyHelper::GetClashResult(PLMIInterferenceSimulation * ipiItfSimu,
	CATListOfCATUnicodeString        & ostrOccurr1Alias,
	CATListOfCATUnicodeString        & ostrOccurr2Alias,
	CATListOfCATUnicodeString        & ostrType,
	CATListOfCATUnicodeString        & oMathPoint1Str,
	CATListOfCATUnicodeString        & oMathPoint2Str,
	CATListOfCATUnicodeString        & oMinDisStr)
{
	HRESULT rc = E_FAIL;
	if (NULL == ipiItfSimu)
	{
		return rc;
	}
	// 9.1/ Collection and storage of Simualtion results in a list
	CATListPtrPLMIInterferenceResult  ListResults;
	rc = ipiItfSimu->GetInterferenceResults(ListResults);
	if (rc == S_OK)
		cout << "GetInterferenceResults  OK \n  ListResults.Size():" << ListResults.Size() << endl;
	else
	{
		cout << "GetInterferenceResults  KO \n  " << endl;
		return rc;
	}
	for (int i = 1; i <= 64; i++)
		cout << "=";
	cout << "\n  " << endl;

	// 10.2/ Iterate through the interferences contained within the results list
	PLMIInterferenceResult     *        pResult = NULL;
	PLMIInterferenceResult::ResultType  ResultType = PLMIInterferenceResult::ResultTypeUndefined;
	CATUnicodeString                    strtmp("");
	for (int i = 1; i <= ListResults.Size(); i++)
	{
		cout << "\nNO." << i << ":" << endl;

		pResult = ListResults[i];
		CATIPLMNavOccurrence    *    piPLMNavOccur1(NULL);
		CATIPLMNavOccurrence    *    piPLMNavOccur2(NULL);
		pResult->GetFirstProduct(piPLMNavOccur1);
		pResult->GetSecondProduct(piPLMNavOccur2);
		CATUnicodeString       NavOccurStr1("");
		CATUnicodeString       NavOccurStr2("");
		if (piPLMNavOccur1 != NULL)
		{
			CATIAlias_var    spAlias(NULL_var);
			spAlias = (CATIAlias_var)piPLMNavOccur1;
			if (spAlias != NULL_var)
			{
				NavOccurStr1 = spAlias->GetAlias();
				cout << "NavOccurStr1 :	" << NavOccurStr1 << endl;
				ostrOccurr1Alias.Append(NavOccurStr1);

			}
		}
		if (piPLMNavOccur2 != NULL)
		{
			CATIAlias_var    spAlias(NULL_var);
			spAlias = (CATIAlias_var)piPLMNavOccur2;
			if (spAlias != NULL_var)
			{
				NavOccurStr2 = spAlias->GetAlias();
				cout << "NavOccurStr2 :	" << NavOccurStr2 << endl;
				ostrOccurr2Alias.Append(NavOccurStr2);
			}
		}
		// 10.3/ Retrieve the interference result type
		CATUnicodeString        StrType("");
		if (pResult) rc = pResult->GetResultType(ResultType);
		if (ResultType == PLMIInterferenceResult::ResultTypeClash)
		{
			strtmp = NavOccurStr1 + CATUnicodeString(" + ") + NavOccurStr2 + " Clash";
			StrType = CATUnicodeString("Clash");
		}
		else if (ResultType == PLMIInterferenceResult::ResultTypeContact)
		{
			strtmp = NavOccurStr1 + CATUnicodeString(" + ") + NavOccurStr2 + " Contact";
			StrType = CATUnicodeString("Contact");
		}
		else if (ResultType == PLMIInterferenceResult::ResultTypeClearance)
		{
			strtmp = NavOccurStr1 + CATUnicodeString(" + ") + NavOccurStr2 + " Clearance";
			StrType = CATUnicodeString("Clearance");
		}
		else if (ResultType == PLMIInterferenceResult::ResultTypeNoInterference)
		{
			strtmp = NavOccurStr1 + CATUnicodeString(" + ") + NavOccurStr2 + " No Interference";
			StrType = CATUnicodeString("No Interference");
		}
		else if (ResultType == PLMIInterferenceResult::ResultTypeUndefined)
		{
			strtmp = NavOccurStr1 + CATUnicodeString(" + ") + NavOccurStr2 + " Undefined";
			StrType = CATUnicodeString("Undefined");
		}
		else
		{
			rc = E_FAIL;
		}
		cout << "StrType :	" << StrType << endl;
		ostrType.Append(StrType);

		// 10.4  oMathPoint1, oMathPoint2, oDistance
		CATMathPoint   oMathPoint1;
		CATMathPoint   oMathPoint2;
		double         oDistance(0.);
		rc = pResult->GetGeometricalValues(oMathPoint1, oMathPoint2, oDistance);
		CATUnicodeString    MathPoint1Str("");
		CATUnicodeString    XCoord1Str("");
		CATUnicodeString    YCoord1Str("");
		CATUnicodeString    ZCoord1Str("");
		XCoord1Str.BuildFromNum(oMathPoint1.GetX());
		YCoord1Str.BuildFromNum(oMathPoint1.GetY());
		ZCoord1Str.BuildFromNum(oMathPoint1.GetZ());
		MathPoint1Str = CATUnicodeString("(") + XCoord1Str + CATUnicodeString(",") + YCoord1Str + CATUnicodeString(",") + ZCoord1Str + CATUnicodeString(")");
		CATUnicodeString    MathPoint2Str("");
		CATUnicodeString    XCoord2Str("");
		CATUnicodeString    YCoord2Str("");
		CATUnicodeString    ZCoord2Str("");
		XCoord2Str.BuildFromNum(oMathPoint2.GetX());
		YCoord2Str.BuildFromNum(oMathPoint2.GetY());
		ZCoord2Str.BuildFromNum(oMathPoint2.GetZ());
		MathPoint1Str = CATUnicodeString("(") + XCoord2Str + CATUnicodeString(",") + YCoord2Str + CATUnicodeString(",") + ZCoord2Str + CATUnicodeString(")");

		CATUnicodeString    MinDisStr("");
		MinDisStr.BuildFromNum(oDistance);
		cout << "MathPoint1Str :	" << MathPoint1Str << endl;
		cout << "MathPoint2Str :	" << MathPoint2Str << endl;
		cout << "MinDisStr :	" << MinDisStr << endl;
		oMathPoint1Str.Append(MathPoint1Str);
		oMathPoint2Str.Append(MathPoint2Str);
		oMinDisStr.Append(MinDisStr);

	}

	return rc;
}

//HRESULT  fengyHelper::CreateExcelFile(CATUnicodeString &istrfileName,
//	CATListOfCATUnicodeString        & istrOccurr1Alias,
//	CATListOfCATUnicodeString        & istrOccurr2Alias,
//	CATListOfCATUnicodeString        & istrType,
//	CATListOfCATUnicodeString        & iMathPoint1Str,
//	CATListOfCATUnicodeString        & iMathPoint2Str,
//	CATListOfCATUnicodeString        & iMinDisStr)
//{
//	HRESULT rc = E_FAIL;
//	CATUnicodeString strDLLPath = CATUnicodeString("");
//	rc = GetCurrentDLLPath(strDLLPath);
//	if (S_OK != rc || CATUnicodeString("") == strDLLPath)      return rc;
//	cout << "strDLLPath ：     " << strDLLPath << endl;
//
//	//// 测试 远程方式读取excel文件！
//	//strDLLPath = CATUnicodeString("\\\\10.36.69.230\\超级共享\\01-液压管路三维化定制\\00-程序历史版本\\V6\\config\\");
//	CATUnicodeString strTemplate = strDLLPath + CATUnicodeString("ClashExportTemplate\\ClashExportTemplate.xlsx");
//	cout << "strTemplate :     " << strTemplate << endl;
//
//
//	//将信息写入Excel并保存
//	ClsOfExcelOperation  *  pClsOfExcelOperation = new  ClsOfExcelOperation(strTemplate);
//	if (!pClsOfExcelOperation)
//	{
//		delete pClsOfExcelOperation;
//		pClsOfExcelOperation = NULL;
//		return E_FAIL;
//	}
//
//	// 测试 get 数据
//	CATUnicodeString Content;
//	rc = pClsOfExcelOperation->GetItemText(1, 2, Content);
//	if (FAILED(rc))
//		cout << " 获取 GetItemText 失败 " << endl;
//	else
//		cout << "GetItemText(1, 2) ：     " << Content << endl;
//
//
//	// 写入数据
//
//	for (int i = 1; i <= istrOccurr1Alias.Size(); i++)
//	{
//		CATUnicodeString strQue("");
//		strQue.BuildFromNum(i);
//		pClsOfExcelOperation->SetItemText(i + 1, 1, strQue.ConvertToChar());
//		pClsOfExcelOperation->SetItemText(i + 1, 2, istrOccurr1Alias[i].ConvertToChar());
//		pClsOfExcelOperation->SetItemText(i + 1, 3, istrOccurr2Alias[i].ConvertToChar());
//		pClsOfExcelOperation->SetItemText(i + 1, 4, istrType[i].ConvertToChar());
//		pClsOfExcelOperation->SetItemText(i + 1, 5, iMathPoint1Str[i].ConvertToChar());
//		pClsOfExcelOperation->SetItemText(i + 1, 6, iMathPoint2Str[i].ConvertToChar());
//		pClsOfExcelOperation->SetItemText(i + 1, 7, iMinDisStr[i].ConvertToChar());
//		pClsOfExcelOperation->SetItemColorWithRGB(i + 1, 7, 255, 255, 0);
//	}
//
//
//	// 创建目录
//	CATUnicodeString dir = "C:/temp";					//  路径必须这样？？
//	fengyHelper::CreateDir(dir);
//	CATUnicodeString dir2 = "C:/temp/V6_Clash";					//  路径必须这样？？
//	fengyHelper::CreateDir(dir2);
//
//	//CATUnicodeString NameStr = "excelTest";
//	CATUnicodeString       strBOMPath = CATUnicodeString("C:\\temp\\V6_Clash\\") + istrfileName + CATUnicodeString(".xlsx");	// 新生成的excel
//	cout << "strBOMPath      " << strBOMPath << endl;
//
//	// 另存 退出
//	rc = pClsOfExcelOperation->SaveFile(strBOMPath);
//	delete pClsOfExcelOperation;
//	pClsOfExcelOperation = NULL;
//
//	// 提示一键打开
//	CATUnicodeString tmpMsg = "CreateExcelFile OK，ClashResult 结果存在路径内：";
//	tmpMsg.Append(strBOMPath);
//	//tmpMsg.Append("\n	【打开该文件吗？】");
//	fengyHelper::NotifyWithOpen(tmpMsg, strBOMPath);
//
//	return rc;
//}


HRESULT  fengyHelper::CStringToCATUnicodeString(CString ic_strTemp, CATUnicodeString & ostrCAT)
{
	if (_T("") == ic_strTemp)
	{
		cout << "CString 为空！  " << endl;

		return E_FAIL;
	}
	BSTR bstrContent = ic_strTemp.AllocSysString();
	SysFreeString(bstrContent);

	ostrCAT.BuildFromBSTR(bstrContent);
	cout << "CATUnicodeString ：     " << ostrCAT << endl;
	return S_OK;

}

HRESULT  fengyHelper::CATUnicodeStringToCString(CATUnicodeString & istrCAT, CString oc_strTemp)
{
	HRESULT rc = E_FAIL;

	wchar_t charTmp[100] = { 0 };
	istrCAT.ConvertToWChar(charTmp);
	oc_strTemp.Format(_T("%s"), charTmp);
	cout << "oc_strTemp:	" << oc_strTemp << endl;

	return S_OK;
}


// DataSetup

HRESULT fengyHelper::GetPointedResourceFromDataSetup(CATUnicodeString iustrActionID, CATBaseUnknown_var& ospUKAction)
{
	HRESULT hr = E_FAIL;

	ospUKAction = NULL_var;

	PLMISetupDataFinder* piSetupDataFinder = PLMSetupDataGlobalFunctions::GetPLMSetupDataFinder();
	if (NULL == piSetupDataFinder)
	{
		return E_FAIL;
	}

	hr = piSetupDataFinder->FindPointedResource(iustrActionID, NULL_var, ospUKAction);
	piSetupDataFinder->Release();
	piSetupDataFinder = NULL;
	if (FAILED(hr) || NULL_var == ospUKAction)
	{
		return E_FAIL;
	}

	return S_OK;
}


// Search 2021.5.24
CATBoolean fengyHelper::SearchPrdByTitle(CATUnicodeString usTitle, CATOmbLifeCycleRootsBag &ioLifeCycleRootsBag, CATIPLMNavReference_var &ospRefOnSearch, CATUnicodeString  isPLMType)
{
	if (usTitle == "" || NULL_var != ospRefOnSearch) return FALSE;

	HRESULT rc = S_OK;
	CATIType_var spVPMReferenceType;
	//CATUnicodeString isPLMType = "VPMReference";
	cout << "isPLMType：" << isPLMType << endl;

	rc = CATCkePLMNavPublicServices::RetrieveKnowledgeType(isPLMType, spVPMReferenceType);
	//if (FAILED(rc))
	//	rc = CATCkePLMNavSpecializationAccessPublicServices::RetrieveSpecializationType (isPLMType, spVPMReferenceType);

	if (SUCCEEDED(rc))
	{
		CATAdpAttributeSet AttributeSet;
		AttributeSet.AddAttribute("V_Name", usTitle);
		CATListPtrCATAdpQueryResult QueryResults;
		rc = CATAdpPLMQueryServices::GetElementsFromAttributes(spVPMReferenceType, AttributeSet, QueryResults);
		if (SUCCEEDED(rc))
		{
			if (QueryResults.Size() >= 1)
			{
				cout << "the size of " << usTitle << "in database is : " << QueryResults.Size() << std::endl;

				CATAdpQueryResult * pQueryResult = QueryResults[1];	// 仅取第一个？
				if (NULL != pQueryResult)
				{
					CATIAdpPLMIdentificator *pPLMId = NULL;
					rc = pQueryResult->GetIdentifier(pPLMId);
					if (NULL != pPLMId)
					{
						CATAdpOpenParameters openParameters(CATAdpExpandParameters::Authoring);
						CATAdpOpener opener(ioLifeCycleRootsBag, openParameters);
						CATIPLMNavReference* pRefOnSearch = NULL;
						rc = opener.CompleteAndOpen(pPLMId, IID_CATIPLMNavReference, (void**)&pRefOnSearch);
						if (FAILED(rc))
						{
							std::cout << "FAILED in CompleteAndOpen" << std::endl;
						}

						ospRefOnSearch = pRefOnSearch;

						pRefOnSearch->Release(); pRefOnSearch = NULL;
						if (NULL != pPLMId) { pPLMId->Release(); pPLMId = NULL; }
					}
					else
					{
						std::cout << "FAILED in GetIdentifier" << std::endl;
					}
				}
			}
		}
		QueryResults.RemoveAll();
	}

	if (NULL_var == ospRefOnSearch)  return FALSE;
	return TRUE;
}

// from edu 
HRESULT fengyHelper::GetAdpPLMID(CATUnicodeString externalID, CATIAdpPLMIdentificator* &opPLMIdent, CATString imodelerType)
{
	HRESULT hr = E_FAIL;
	if (externalID == "" || imodelerType == "")
		return E_FAIL;

	CATString           attrId("PLM_ExternalID");
	CATAdpIdentificationSet              identificationSetRootPrd;

	CATIType_var spIAdpPLMCoreRef;

	hr = CATCkePLMNavPublicServices::RetrieveKnowledgeType(imodelerType, spIAdpPLMCoreRef);
	if (SUCCEEDED(hr) && NULL_var != spIAdpPLMCoreRef)
	{
		identificationSetRootPrd.AddAttribute(attrId, externalID);

		CATLISTP(CATAdpQueryResult)      listP_QueryResults;
		CATAdpQueryResult *pQueryResult = NULL;  //  Not  to  be  Deleted
		CATIAdpPLMIdentificator *pIPLMIdent = NULL;  //  To  be  Released

		hr = CATAdpPLMQueryServices::GetElementsFromAttributes(spIAdpPLMCoreRef, identificationSetRootPrd, listP_QueryResults);
		int listQR_Size = listP_QueryResults.Size();

		if (SUCCEEDED(hr) && listQR_Size > 0)
		{
			pQueryResult = listP_QueryResults[1];
			if (NULL != pQueryResult)
			{
				hr = pQueryResult->GetIdentifier(pIPLMIdent);
				if (SUCCEEDED(hr) && NULL != pIPLMIdent)
				{
					opPLMIdent = pIPLMIdent;
					pIPLMIdent->Release();
					pIPLMIdent = NULL;
				}
			}
		}
	}

	return hr;
}
// from JD 套路： unknown - occur- refer -plmComponent- type- name
// ------------------------------------------------
HRESULT fengyHelper::GetObjectType(CATBaseUnknown* ipUKObject, CATUnicodeString& oustrObjectType)
{
	HRESULT hr = E_FAIL;

	if (NULL == ipUKObject)
	{
		return E_INVALIDARG;
	}

	CATIPLMNavOccurrence_var spiNavOccOnObject = ipUKObject;
	if (NULL_var == spiNavOccOnObject)
	{
		return E_FAIL;
	}

	CATIPLMNavReference* piNavRefOnObject = NULL;
	hr = spiNavOccOnObject->GetRelatedReference(piNavRefOnObject);
	if (FAILED(hr) || NULL == piNavRefOnObject)
	{
		return E_FAIL;
	}

	CATIPLMComponent_var spiComponentOnObject = piNavRefOnObject;
	if (NULL_var == spiComponentOnObject)
	{
		return E_FAIL;
	}

	CATIAdpType* piAdpType = NULL;
	spiComponentOnObject->GetAdpType(piAdpType);

	CATIType* piType = NULL;
	CATPLMTypeServices::GetKweTypeFromAdpType(piAdpType, piType);		// CATIType

	oustrObjectType = piType->Name();

	return S_OK;
}

// SaveAs by  CATAdpDuplicator  2021.5.26
// 默认不修改属性值 的另存为！ 或者说 调用时 前文已经 修改过！
HRESULT fengyHelper::SaveAs(CATIAdpPLMIdentificator *ipPLMId, CATUnicodeString  istrPrefix)
{
	HRESULT rc = E_FAIL;
	if (NULL == ipPLMId)
	{
		cout << "SaveAs() 形参 CATIAdpPLMIdentificator NULL！ " << endl;
		return rc;
	}

	// 录入规则，更改属性
	CATAdpAttributeSet attributeSet;
	//attributeSet.AddAttribute("V_Name", istrPrefix);
	//attributeSet.AddAttribute("PLM_ExternalID", istrPrefix);

	// AddElement
	CATAdpDuplicator duplicator;
	if (FAILED(duplicator.AddElement(ipPLMId, attributeSet)))
	{
		cout << "SaveAs() AddElement KO！ " << endl;
		return rc;
	}

	if (FAILED(duplicator.Duplicate()))
	{
		cout << "SaveAs() Duplicate KO！ " << endl;
		Notify("SaveAs() Duplicate KO！");

		CATIAdpPLMErrorReviewer * pErrorReviewer = NULL;
		duplicator.GetErrorReviewer(pErrorReviewer);
		////manage errors
		//CATSysReleasePtr(pErrorReviewer);

		// delete the PLM Error Reviewer after use
		pErrorReviewer->Release();
		pErrorReviewer = NULL;

		return rc;
	}

	return S_OK;
}

//Int数字转字符串
CATUnicodeString fengyHelper::IntToStr(int i)
{
	CATUnicodeString usStr;
	usStr.BuildFromNum(i, "%d");
	return usStr;
}

//double转字符串
CATUnicodeString fengyHelper::DoubleToStr(double d)
{
	CATUnicodeString usStr;
	usStr.BuildFromNum(d, "%g");
	return usStr;
}

//Str->int
int fengyHelper::Str2Int(CATUnicodeString usStr)
{
	int dValue;
	int isSucced = usStr.ConvertToNum(&dValue, "%d");
	if (isSucced == 0)		// KO！
		return -1;
	else
		return dValue;
}

//Str->double
double fengyHelper::StrToDouble(CATUnicodeString usStr)
{
	double dValue = 0;
	usStr.ConvertToNum(&dValue, "%le");
	return dValue;
}


// JD 嵌套拆分所有标记字符（iStrSplit）！
CATBoolean fengyHelper::SplitString(CATUnicodeString iStrString, CATUnicodeString iStrSplit, CATListOfCATUnicodeString &oStrList)
{
	if (iStrString == "" || iStrSplit == "") return FALSE;

	if (iStrString.SearchSubString(iStrSplit) == -1)
	{
		oStrList.Append(iStrString);
		return TRUE;
	}

	CATUnicodeString strTemp, strTemp2;
	int iLocation = iStrString.SearchSubString(iStrSplit, 0, CATUnicodeString::CATSearchModeForward);
	int iSize;
	strTemp = iStrString;
	while (iLocation != -1)
	{
		strTemp2 = strTemp.SubString(0, iLocation);
		oStrList.Append(strTemp2);
		iSize = strTemp.GetLengthInChar();

		strTemp2 = strTemp.SubString(iLocation + iStrSplit.GetLengthInChar(), iSize - iLocation - iStrSplit.GetLengthInChar());
		strTemp = strTemp2;
		iLocation = strTemp.SearchSubString(iStrSplit, 0, CATUnicodeString::CATSearchModeForward);

		if (iLocation == -1)//&& strTemp2 != ""
			oStrList.Append(strTemp2);
	}

	return TRUE;
}
//JD
CATBoolean fengyHelper::GetFeatureFromSelect(CATBaseUnknown_var ispSelect, CATIMmiMechanicalFeature_var &ospSpecOnFeature)
{
	HRESULT rc = E_FAIL;
	CATIMmiMechanicalFeature_var spSpecOnFeature = NULL_var;
	spSpecOnFeature = ispSelect;
	cout << "GetFeatureFromSelect 11111" << endl;

	if (spSpecOnFeature != NULL_var)
	{
		ospSpecOnFeature = spSpecOnFeature;
		cout << "GetFeatureFromSelect 222222" << endl;

	}
	else
	{
		CATIMmiUseFeaturize_var spFeaturize = ispSelect;
		cout << "GetFeatureFromSelect 333333" << endl;

		if (!!spFeaturize)
		{
			CATIMmiUseMfBRep_var oBRepFeature;
			rc = spFeaturize->Featurize(oBRepFeature, MfPermanentBody | MfLastFeatureSupport | MfRelimitedFeaturization, CATMmrDefaultLimitationType);
			cout << "GetFeatureFromSelect 4444444" << endl;

			if (SUCCEEDED(rc) && oBRepFeature != NULL_var)
			{
				cout << "GetFeatureFromSelect 55555" << endl;

				ospSpecOnFeature = oBRepFeature;
			}
		}
	}
	cout << "GetFeatureFromSelect 66666" << endl;

	if (!!ospSpecOnFeature)
		return TRUE;
	cout << "GetFeatureFromSelect 7777" << endl;

	return FALSE;
}

// GetRepReferenceByOccurrence  from JD

HRESULT fengyHelper::GetRepReferenceByOccurrence(CATIPLMNavOccurrence* ipiNavOccurrence, CATIPLMNavRepReference*& opiNavRepReference)
{
	HRESULT hr = E_FAIL;
	opiNavRepReference = NULL;

	if (NULL == ipiNavOccurrence)
	{
		return E_INVALIDARG;
	}

	CATIPLMNavReference* piNavReference = NULL;
	hr = ipiNavOccurrence->GetRelatedReference(piNavReference);
	if (FAILED(hr) || NULL == piNavReference)
	{
		return E_FAIL;
	}

	CATPLMCoreType ePLMCoreType = PLMCoreRepInstance;
	CATListPtrCATIPLMNavEntity listEntityOnRepInstance;
	hr = piNavReference->ListChildren(listEntityOnRepInstance, 1, &ePLMCoreType);
	if (FAILED(hr) || listEntityOnRepInstance.Size() == 0)
	{
		return E_FAIL;
	}

	for (int ii = 1; ii <= listEntityOnRepInstance.Size(); ii++)
	{
		CATIPLMNavEntity* piNavEntity = listEntityOnRepInstance[ii];
		if (NULL == piNavEntity)
		{
			continue;
		}

		CATIPLMNavRepInstance* piNavRepInstance = NULL;
		hr = piNavEntity->QueryInterface(IID_CATIPLMNavRepInstance, (void**)&piNavRepInstance);
		if (FAILED(hr) || NULL == piNavRepInstance)
		{
			continue;
		}

		CATIPLMNavRepReference* piNavRepReference = NULL;
		piNavRepInstance->GetRepReferenceInstanceOf(piNavRepReference);
		if (FAILED(hr) || NULL == piNavRepReference)
		{
			continue;
		}

		CATIPsiRepresentationReference_var spiPsiRepRef = piNavRepReference;
		if (NULL_var == spiPsiRepRef)
		{
			continue;
		}

		CATUnicodeString ustrMainDataType = "";
		spiPsiRepRef->GetMainDataType(ustrMainDataType);
		if (ustrMainDataType == "CATPart")
		{
			opiNavRepReference = piNavRepReference;
			break;
		}
	}

	if (NULL == opiNavRepReference)
	{
		return E_FAIL;
	}

	return S_OK;
}

//根据Occ获取PrtContainer   JD CAAEwisGeneralCls.cpp
CATBoolean fengyHelper::GetContByOcc(CATIPLMNavOccurrence_var ispOcc, CATIMmiPrtContainer_var &ospPrtCont)
{
	HRESULT rc = E_FAIL;
	CATIMmiPrtContainer * piPrtContainer = NULL;
	if (NULL_var != ispOcc)
	{
		CATListPtrCATIPLMNavRepOccurrence   listRepOcc;
		rc = ispOcc->ListRepChildren(listRepOcc);
		for (int i = 1; i <= listRepOcc.Size(); i++)
		{
			//CATIAlias_var spAlias = listRepOcc[i];
			//CATUnicodeString usEachRepOcc = spAlias->GetAlias();
			if (ChangeOccModeToEdit(ispOcc))
			{
				rc = listRepOcc[i]->RetrieveApplicativeContainer("CATPrtCont", IID_CATIMmiPrtContainer, (void**)&piPrtContainer);
				if (SUCCEEDED(rc) && NULL != piPrtContainer)
				{
					ospPrtCont = piPrtContainer;
					if (piPrtContainer)
					{
						piPrtContainer->Release();
						piPrtContainer = NULL;
					}
					return TRUE;
				}
			}
		}
	}
	if (piPrtContainer) { piPrtContainer->Release(); piPrtContainer = NULL; }
	return FALSE;
}

//转换到编辑模式
CATBoolean  fengyHelper::ChangeOccModeToEdit(CATIPLMNavOccurrence_var ispOcc)
{
	HRESULT rc = E_FAIL;
	if (NULL_var == ispOcc) { return FALSE; }
	CATListPtrCATIPLMNavRepOccurrence  listRepChildren;
	rc = ispOcc->ListRepChildren(listRepChildren);
	if (SUCCEEDED(rc))
	{
		for (int i = 1; i <= listRepChildren.Size(); i++)
		{
			CATIPLMNavRepReference * pRepRefOnChild = NULL;
			CATIPLMNavRepOccurrence_var spRepOcc = listRepChildren[i];
			rc = spRepOcc->GetRelatedRepReference(pRepRefOnChild);
			if (SUCCEEDED(rc) && NULL != pRepRefOnChild)
			{
				CATIPsiRepresentationLoadMode *piRepLoadMode = NULL;
				rc = pRepRefOnChild->QueryInterface(IID_CATIPsiRepresentationLoadMode, (void **)&piRepLoadMode);
				if (piRepLoadMode &&  SUCCEEDED(rc))
				{
					rc = piRepLoadMode->ChangeLoadingMode(CATIPsiRepresentationLoadMode::EditMode);
					if (FAILED(rc))
					{
						return FALSE;
					}
					if (piRepLoadMode) { piRepLoadMode->Release(); piRepLoadMode = NULL; }
				}
				if (pRepRefOnChild) { pRepRefOnChild->Release(); pRepRefOnChild = NULL; }
			}
		}
		listRepChildren.RemoveAll();
	}
	if (FAILED(rc)) return FALSE;
	return TRUE;
}


// 获取  ParamList  fengy   2021.6.8
BOOL fengyHelper::GetParamList(CATIMmiPrtContainer_var ispPrtContainer, CATLISTV(CATICkeParm_var) &ospParmList)
{
	if (NULL_var == ispPrtContainer)
	{
		return FALSE;
	}

	CATIMmiMechanicalFeature_var spMechPart;
	ispPrtContainer->GetMechanicalPart(spMechPart);
	CATIParmPublisher_var spParamPub = spMechPart;
	if (spParamPub == NULL_var)
	{
		Notify("spParamPub 强转KO！");
		return FALSE;
	}

	//判断是否存在该参数
	CATIKweModelServices_var spModelService = CATCkeGlobalFunctions::GetModelServices();
	if (spModelService == NULL_var)
	{
		Notify("GetModelServices  KO！");
		return FALSE;
	}

	CATListValCATBaseUnknown_var listParam;
	//CATCkeListOf(Parm)  listParam;
	spModelService->VisibleParms(spParamPub, listParam, 1, 1);
	int size = listParam.Size();
	cout << "	listParam.Size():	" << size << endl;

	for (int a = 1; a <= size; a++)
	{
		CATICkeParm_var spEachParm = listParam[a];
		ospParmList.Append(spEachParm);
	}
	return TRUE;

}

////  2021.6.9 fengy  提前 判断是否存在文件， 尝试避免打开错误；――针对 CExcelRW::IsFileExist
//BOOL fengyHelper::IsXlsFileExist(CATUnicodeString istrXlsFile)
//{
//	BOOL flag = FALSE;
//	void * pExcelOperation = new CExcelRW();
//	CExcelRW *pExcelRW = static_cast<CExcelRW*>(pExcelOperation);
//	if (NULL == pExcelRW)
//		return flag;
//	if (FALSE == pExcelRW->IsFileExist(istrXlsFile.ConvertToChar(), FALSE))
//		return flag;
//	else
//		return TRUE;
//}
//
////  2021.6.16 fengy  利用黄玲玲的 excel组件！
//HRESULT fengyHelper::getKnowledgeListsByResourceExcel(CATUnicodeString iExcelFile,
//	CATListValCATUnicodeString & oHeadList,
//	CATListValCATUnicodeString & oValueList,
//	int iupperRow,
//	int ileftColumn)
//{
//	HRESULT rc = E_FAIL;
//
//	if (FALSE == IsXlsFileExist(iExcelFile))
//	{
//		fengyHelper::Notify("请检查文件：\n" + iExcelFile + " \n 是否已存在？");
//		return rc;
//	}
//
//	// 0- 打开excel
//	ClsOfExcelOperation  *  pKnowledgeExcel = new  ClsOfExcelOperation(iExcelFile);
//	if (!pKnowledgeExcel)
//	{
//		delete pKnowledgeExcel;
//		pKnowledgeExcel = NULL;
//		return E_FAIL;
//	}
//
//	// 测试 get 数据
//	CATUnicodeString Content;
//	for (int row = iupperRow; row <= MAX_ROW; row++)
//	{
//		Content = "";		 // 循环入口 置空！否则 数据保留 右下角的数据！
//
//		rc = pKnowledgeExcel->GetItemText(row, ileftColumn, Content);
//		//if (FAILED(rc))				// 空格 代表 返回为 E_FAIL！
//		//{
//		//	Notify("表格：\n" + iExcelFile + "\n 单元格（ "+ row +" , "+ ileftColumn +" ）获取KO！");
//		//	return E_FAIL;
//		//}
//
//		Content = Content.Strip(CATUnicodeString::CATStripModeBoth, ' ');
//
//		if (0 == Content.GetLengthInByte())
//		{
//			break;
//		}
//		else
//		{
//			oHeadList.Append(Content);
//			cout << Content << "		";
//
//			pKnowledgeExcel->GetItemText(row, ileftColumn + 1, Content);
//			oValueList.Append(Content);
//			cout << Content << endl;
//		}
//	}
//	cout << "oHeadList.Size():" << oHeadList.Size() << endl;
//
//
//	return S_OK;
//
//}

// 规则 1 ：根据 件号，区分类别

// 为了简化规则from 液压管路三维化件号编排规则.xlsx，多次复用！ fengy 2021.6.16
CATUnicodeString fengyHelper::CheckPartType(CATIPLMNavOccurrence_var ispChildOnOcc, CATUnicodeString iPartNumber)
{
	if (NULL_var == ispChildOnOcc)
	{
		Notify(iPartNumber + "节点下 ispChildOnOcc 为空！");
		return "";
	}

	if ("" == iPartNumber)
	{
		return "件号为空！";
	}
	else
	{
		cout << "iPartNumber : " << iPartNumber << endl;

		int sizeOfiPartNumber = iPartNumber.GetLengthInChar();
		cout << "iPartNumber.GetLengthInChar(): " << sizeOfiPartNumber << endl;

		if (iPartNumber.SearchSubString("R_", 0, CATUnicodeString::CATSearchModeBackward) != -1)
		{
			return "R模型";
			cout << "CheckPartType_R模型" << endl;
		}
		else if ((iPartNumber.SearchSubString("G7", 0, CATUnicodeString::CATSearchModeBackward) != -1) && (14 == sizeOfiPartNumber))
		{
			if (S_OK == isTube(ispChildOnOcc))
			{
				return "导管";
			}
			else if (iPartNumber.SearchSubString("2910A00", 0, CATUnicodeString::CATSearchModeBackward) != -1)

				return "块卡";

			else if (iPartNumber.SearchSubString("2910A0", 0, CATUnicodeString::CATSearchModeBackward) != -1)
				return "标准支架";
			else
				return "支架";

		}
		else if ((iPartNumber.SearchSubString("G2", 0, CATUnicodeString::CATSearchModeBackward) != -1) && (14 == sizeOfiPartNumber))
			return "顶层图";
		else if ((iPartNumber.SearchSubString("G4", 0, CATUnicodeString::CATSearchModeBackward) != -1) && (14 == sizeOfiPartNumber))
		{
			if (iPartNumber.SearchSubString("2910A00", 0, CATUnicodeString::CATSearchModeBackward) != -1)
				return "块卡组件";
			else
				return "组件";
		}

		else if ((iPartNumber.SearchSubString("G9", 0, CATUnicodeString::CATSearchModeBackward) != -1) && (14 == sizeOfiPartNumber))
			return "设备";
		else
			return "标准件细分 or RUN";
	}

}

// 2021.6.16 fengy 判断是否为管路件
HRESULT fengyHelper::isTube(CATIPLMNavOccurrence_var ispChildOnOcc)
{
	HRESULT rc = E_FAIL;
	if (NULL_var == ispChildOnOcc)
	{
		Notify(" isTube 判断时，节点下 ispChildOnOcc 为空！");
		return rc;
	}
	CATUnicodeString tmpType;
	rc = GetObjectType((CATBaseUnknown*)ispChildOnOcc, tmpType);
	cout << "tmpType：  " << tmpType << endl;

	if (FAILED(rc) || CATUnicodeString("") == tmpType)
	{
		cout << "GetObjectType KO" << endl;
		fengyHelper::Notify("GetObjectType  KO！");
		return rc;
	}
	else if (CATUnicodeString("Piping_Rigid_Pipe") == tmpType)
		return S_OK;
	else
		return E_FAIL;

}

// 标准件细分 改编 fengy 2021.6.17
CATUnicodeString fengyHelper::getDetailTypeFromStandardType(CATUnicodeString & iPartNumber,
	CATListOfCATUnicodeString &iheadList,
	CATListOfCATUnicodeString &itypeList)
{
	CATUnicodeString oType;
	if (iPartNumber == NULL)
	{
		return "缺失零件名称!";
	}
	if (0 == iheadList.Size() || 0 == itypeList.Size() ||
		(iheadList.Size() != itypeList.Size()))
	{
		Notify(" getDetailTypeFromStandardType input KO!");			// debug！
		return "ERROR INPUT!";
	}

	//CATISpecObject_var spObj = FindPart(iPartNumber, ipiProductOnRoot);
	//if (spObj == NULL_var)
	//{
	//	Notify(" getDetailTypeFromStandardType-FindPart input KO!");		// debug！
	//	return "ERROR INPUT!";
	//}

	// 标准件的细分
	int countPass = 0;
	for (int i = 1; i <= iheadList.Size(); i++)
	{
		if (-1 != iPartNumber.SearchSubString(iheadList[i], 0, CATUnicodeString::CATSearchModeBackward))		// 找到！
		{
			oType = itypeList[i];						// 返回对应的类别！
			break;
		}
		else
		{
			countPass++;
			continue;
		}
	}

	if (countPass == iheadList.Size())
	{
		return "知识库中不含有该标准件类别！";
	}
	return oType;
}



CATUnicodeString fengyHelper::GetAliasName(CATBaseUnknown * ipBaseUnknown)
{
	CATUnicodeString ElementName("");
	if (NULL != ipBaseUnknown)
	{
		CATIAlias_var spAlias = ipBaseUnknown;
		if (NULL_var != spAlias)  ElementName = spAlias->GetAlias();
	}
	return ElementName;
}


//fengy 2021.12.1 根据 ref \ contextFatherOcc 获取Occ 
CATIPLMNavOccurrence_var fengyHelper::GetOccFromRef(CATIPLMNavOccurrence_var ispOccOnFarther, CATIPLMNavReference_var ispRef)
{
	if (ispOccOnFarther != NULL_var && ispRef != NULL_var)
	{
		//cout<<"在"<<GetObjTitle(spOccOnFarther)<<"下获取"<<GetObjTitle(spIns)<<"的Occ"<<endl;

		CATListPtrCATIPLMNavOccurrence listOccOnRef;
		ispRef->ListRelatedOccurrences(ispOccOnFarther, listOccOnRef);
		cout << "GetOccFromRef size:" << listOccOnRef.Size() << endl;

		if (listOccOnRef.Size() == 1)
		{
			return listOccOnRef[1];
		}
	}

	return NULL_var;
}

// fengy 2021.12.16  010~990 解析
int fengyHelper::ParseFormatCode(CATUnicodeString isStartingRefTitle)
{
	int ret = -1;
	if (CATUnicodeString("") == isStartingRefTitle)
	{
		cout<<"# ParseFormatCode 输入为空！"<<endl;
		return ret;
	}
	cout << "# ParseFormatCode 输入："<< isStartingRefTitle << endl;
	if( 3 != isStartingRefTitle.GetLengthInChar())
	{
		cout << "# ParseFormatCode 的字符个数 不为 3！" << endl;
		return ret;
	}

	int iLocation = isStartingRefTitle.SearchSubString(CATUnicodeString("0"), 0, CATUnicodeString::CATSearchModeForward);
	if (0 == iLocation)
		isStartingRefTitle = isStartingRefTitle.SubString(iLocation + 1, isStartingRefTitle.GetLengthInChar() - 1);
	cout << "# isStartingRefTitle 处理前：" << isStartingRefTitle << endl;
	
	ret = fengyHelper::Str2Int(isStartingRefTitle) / 10;
	cout << "# isStartingRefTitle 处理后：" << ret << endl;

	return ret;
}


// fengy 2021.12.26  从选定 获取当前list 内的index  by PLM_ExternalID
int  fengyHelper::GetCurIdOnMAList(CATUnicodeString istrRefID, CATIPLMNavReference_var ispRootRef)
{
	int index = -1;
	if (CATUnicodeString("") == istrRefID || NULL_var == ispRootRef)
	{
		Notify("GetCurIdOnMAList 输入 为空！");
		return index;
	}
	// 遍历
	CATPLMCoreType coreType;
	CATListPtrCATIPLMNavEntity childrenList;

	coreType = PLMCoreInstance;
	HRESULT rc = ispRootRef->ListChildren(childrenList, 1, &coreType);
	if (SUCCEEDED(rc))
	{
		cout << "the size of the instances aggregated under Ref is " << childrenList.Size() << endl;

		// ===========================================================================================================
		// 4-2	: For each Part Instances
		// ===========================================================================================================
		int j = 1;
		int  nOP = childrenList.Size();
		while (j <= nOP)
		{
			CATIPLMNavEntity* piNavEntity = childrenList[j];
			if (NULL != piNavEntity)
			{
				CATIPLMNavInstance* piNavInst = NULL;
				rc = piNavEntity->QueryInterface(IID_CATIPLMNavInstance, (void **)&piNavInst);
				if (SUCCEEDED(rc))
				{
					CATIPLMNavReference* piNavRef1 = NULL;
					rc = piNavInst->GetReferenceInstanceOf(piNavRef1);	//搜索后的 层级：rootref - inst- ref -rep isnt -repref
					if (SUCCEEDED(rc) && (NULL != piNavRef1))
					{
					
							//  获取ref list 内元素遍历 ref title ，如果重名，更改1st ref title
							CATUnicodeString  strRefID = CUSCAAUtilService::GetObjectAttrValue(piNavRef1, "PLM_ExternalID");
							cout << " #" << j << "  operation ref ID: " << strRefID << endl;
							if (istrRefID == strRefID)
							{
								index = j;
								cout << " 遍历到了OK index ： "<< index << endl;

								break;
							}
						j++;
					}
				}
			}
		}
	}

	return index;
}

// 2021.12.29 fengy from edu ：E:\00dev\dev_3DE_2020\1_edu\CAAProductStructure_1\CAAProductStructure.edu\CAAPstBrowsingProductModel.m\src\CAAPstBrowsingProductModel.cpp
// iTypeOfBrowsing =1  没用到！
// iAllAtributes =true
// iDepth = 0
HRESULT fengyHelper::BrowseReference(CATIPLMNavReference* ipiNavRef, int iTypeOfBrowsing, CATBoolean iAllAtributes, int iDepth)
{
	if (NULL == ipiNavRef) return E_INVALIDARG;


	// Seek the CATIPLMNavEntity* from ipiNavRef
	CATIPLMNavEntity* piNavEnt = NULL;
	HRESULT hr = E_FAIL;
	CATPLMCoreType coreType;
	CATListPtrCATIPLMNavEntity childrenList;

	hr = ipiNavRef->QueryInterface(IID_CATIPLMNavEntity, (void**)&piNavEnt);		// ref- entity
	if (SUCCEEDED(hr))
	{
		// ===========================================================================================================
		// 5-0	: Display the attributes of the reference
		// ===========================================================================================================
		hr = PrintPLMComponent(piNavEnt, iAllAtributes, iDepth);			// 打印当前 ref' 的属性 externalID
		if (SUCCEEDED(hr))
		{
			// ===========================================================================================================
			// 4-1	: Seek the Part Instances aggregated under the Current Reference
			// ===========================================================================================================
			coreType = PLMCoreInstance;
			hr = ipiNavRef->ListChildren(childrenList, 1, &coreType);
			if (SUCCEEDED(hr))
			{
				for (int i = 0; i < iDepth; i++)
					cout << "	";
				cout << "the size of the instances aggregated under Ref is " << childrenList.Size() << endl;

				// ===========================================================================================================
				// 4-2	: For each Part Instances
				// ===========================================================================================================
				int j = 1;
				while (SUCCEEDED(hr) && (j <= childrenList.Size()))
				{
					CATIPLMNavEntity* piNavEntity = childrenList[j];
					if (NULL != piNavEntity)
					{
						// ===========================================================================================================
						// 4-2-0	: Print instance attributes
						// ===========================================================================================================
						hr = PrintPLMComponent(piNavEntity, iAllAtributes, iDepth + 1);			// 打印当前 Instance' 的属性 externalID
						if (S_OK == hr)
						{
							// ===========================================================================================================
							// 4-2-1	: Seek the Part Reference corresponding to the current Part Instance
							// ===========================================================================================================

							// Seek the CATIPLMNavInstance* from CATIPLMNavEntity*
							CATIPLMNavInstance* piNavInst = NULL;
							hr = piNavEntity->QueryInterface(IID_CATIPLMNavInstance, (void **)&piNavInst);
							if (SUCCEEDED(hr))
							{
								// Retrieve the reference of the instance 
								CATIPLMNavReference* piNavRef1 = NULL;
								hr = piNavInst->GetReferenceInstanceOf(piNavRef1);	//搜索后的 层级：rootref - inst- ref -rep isnt -repref
								if (SUCCEEDED(hr) && (NULL != piNavRef1))
								{
									// ===========================================================================================================
									// 4-2-2	: Recursive call to BrowseReference with each of those Part References
									// ===========================================================================================================
									hr = BrowseReference(piNavRef1, iTypeOfBrowsing, iAllAtributes, iDepth + 1 + 1);
									if (SUCCEEDED(hr))
									{
										// Release piNavRef1 pointer
										if (NULL != piNavRef1)
										{
											piNavRef1->Release();
											piNavRef1 = NULL;
										}
									}
								}
								piNavInst->Release();
								piNavInst = NULL;

							}
						}
						// ===========================================================================================================
						// 4-2-3	: Release the pointer in the childrenList
						// ===========================================================================================================
						piNavEntity->Release();
						piNavEntity = NULL;

					}
					j++;

				}// while loop ends				
				childrenList.RemoveAll();
			}
		}
		// Release piNavEnt, since its not required, hereafter
		piNavEnt->Release();
		piNavEnt = NULL;

	}


	return hr;
}


HRESULT fengyHelper::PrintPLMComponent(CATIPLMNavEntity* ipiNavEntity, CATBoolean iAllAtributes, int iDepth)		// 打印所有属性和value
{
	if (NULL == ipiNavEntity) return E_INVALIDARG;

	// if the ioAttributeNameList is empty, oAttributeValueList will be filled up with all public attributes
	//
	CATListOfCATUnicodeString ioAttributeNameList, oAttributeValueList;
	if (FALSE == iAllAtributes)
		ioAttributeNameList.Append("PLM_ExternalID");

	//ioAttributeNameList.Append("V_Name");

	HRESULT hr = E_FAIL;
	hr = ipiNavEntity->GetPublicAttributes(ioAttributeNameList, oAttributeValueList);
	if (SUCCEEDED(hr))
	{
		// Print the PLMExternalID attribute value
		for (int i = 1; i <= ioAttributeNameList.Size(); i++)
		{
			for (int j = 0; j < iDepth; j++)
				cout << "	";
			cout << "<" << (ioAttributeNameList[i]).ConvertToChar() << "=" << (oAttributeValueList[i]).ConvertToChar() << ">" << endl;
		}
	}

	return hr;
}

// fengy 2022.1.7  CATUnicodeString- const char * -char - int
int  fengyHelper::getAsciiNum(CATUnicodeString istrABC)
{
	int asciiNum = -1;
	if (istrABC.GetLengthInChar() !=1)
	{
		CATUnicodeString tmpStr = "#getAsciiNum 输入 str 个数不对！应该为1个！";
		cout<< tmpStr <<endl;
		fengyHelper::Notify(tmpStr);
		return asciiNum;
	}
	//asciiNum= int (strABC.ConvertToChar());		// 强转ko――从“const char *”到“int”的指针截断
	const char *Cchar = istrABC.ConvertToChar();

	int nLen = strlen(Cchar);
	char *c = new char[nLen + 1];
	strcpy(c, Cchar);								// 从“const char *”转换为“char *”

	asciiNum = int(*c);
	cout << "# asciiNum:" << asciiNum << endl;
	return asciiNum;
}

// fengy 2022.1.7    int - char 
char fengyHelper::getAsciiChar(int i)
{
	char c(i);
	cout << "#getAsciiCATUnicodeString char::" << c << endl;
	return c;
}

// fengy 2022.1.7    int - char - CATUnicodeString
CATUnicodeString fengyHelper::getAsciiCATUnicodeString(int i)
{
	//CATUnicodeString c_string = "";
	char c(i);
	cout << "#getAsciiCATUnicodeString char::" << c << endl;
	CATUnicodeString c_string(c);
	cout << "#getAsciiCATUnicodeString c_string::" << c_string << endl;
	return c_string;
}

void fengyHelper::ReleasePtr(CATBaseUnknown * piCBU)
{
	if (NULL != piCBU)
	{
		piCBU->Release();
		piCBU = NULL;
	}
}

//===========================================
//	@func		: printListString
//	@param[in]	: CATListOfCATUnicodeString iListString
//	@retval		: void
//	@from		: CopyRight @Comac
// fengy 2022/01/13 9:24:30  方便遍历打印
void fengyHelper::printListString(CATListOfCATUnicodeString iListString)
{
	int size = iListString.Size();
	if (size == 0)
		return;
	cout << "# printListString: " ;

	for (int i = 1; i <= size; i++)
	{
		if (i != size)
			cout << iListString[i] << " , ";
		else
			cout << iListString[i] << endl;
	}
	return;
}


//===========================================
//	@func		: getCountByFuzzySearch
//	@param[in]	: CATListOfCATUnicodeString iListString
//	@param[in]	: CATUnicodeString iSearchStr
//	@retval		: int
//	@from		: CopyRight @Comac
//  fengy  2022.1.13 9:27:06   获取list中 含字符的个数
int fengyHelper::getCountByFuzzySearch(CATListOfCATUnicodeString iListString, CATUnicodeString iSearchStr)
{
	if (iListString.Size() == 0)
	{
		fengyHelper::Notify("getCountByFuzzySearch 输入的strList 为空！");
		return 0;
	}
	int size = 0;
	for (int i = 1; i <= iListString.Size(); i++)
	{
		if(iListString[i].SearchSubString(iSearchStr) !=-1)
			size++;
	}
	return size;
}


//===========================================
//	@func		: DisplayErrorMessage
//	@param[in]	: HRESULT hr
//	@param[in]	: CATUnicodeString RoutineName
//	@retval		: int
//	@from		: CopyRight @Comac
//  fengy 		: 2022.1.14 12:28:27  		Global routine to display error returned by routines !from edu:E:\00dev\dev_3DE_2020\1_edu\CAAProductStructure_1\CAAPLMClientAdapter.edu\CAAAdpVersioning.m\src\CAAAdpVersioning.cpp
int fengyHelper::DisplayErrorMessage(HRESULT hr, CATUnicodeString RoutineName)
{
	CATUnicodeString tempMsg;
	cout << "Failure at " << RoutineName.ConvertToChar() << endl;

	int returnvalue = 1;

	// Accessing the blocking error
	CATError* pErr = CATError::CATGetLastError(hr);
	if (NULL != pErr)
	{
		CATUnicodeString ErrorMessage = pErr->GetNLSMessage();
		cout << "The error message is: " << ErrorMessage.ConvertToChar() << endl;
		tempMsg = "FAILED at ";
		tempMsg.Append(RoutineName.ConvertToChar());
		tempMsg.Append("  ！！The error message is: ");
		tempMsg.Append(ErrorMessage.ConvertToChar());
		Notify(tempMsg  );

		pErr->Release();
		pErr = NULL;

		returnvalue = 0;
	}

	return returnvalue;
}

// from RQ
HRESULT fengyHelper::SetObjectAttrString(CATBaseUnknown * ipBaseUnknown, CATUnicodeString sAttrName, CATUnicodeString sAttrValue)
{
	if (sAttrName == "")
		return S_FALSE;
	if (ipBaseUnknown == NULL)
		return S_FALSE;
	CATIPLMComponent *spCompObject = NULL;
	HRESULT rc = ipBaseUnknown->QueryInterface(IID_CATIPLMComponent, (void**)&spCompObject);
	if (spCompObject == NULL)
		return S_FALSE;

	CATICkeObject * spCkeObject = NULL;
	rc = spCompObject->QueryInterface(IID_CATICkeObject, (void**)&spCkeObject);
	_RELEASE_PTR_(spCompObject);
	if (spCkeObject == NULL)
		return S_FALSE;

	rc = CATCkeObjectAttrWriteServices::SetValueWithString(spCkeObject, sAttrName, sAttrValue);
	_RELEASE_PTR_(spCkeObject);
	return rc;
}

// from RQ
CATUnicodeString fengyHelper::GetObjectAttrValue(CATBaseUnknown * ipBaseUnknown, CATUnicodeString sAttrName)
{
	CATUnicodeString sExternalID("");
	if (ipBaseUnknown == NULL)
		return sExternalID;
	CATIPLMComponent *spCompObject = NULL;
	HRESULT rc = ipBaseUnknown->QueryInterface(IID_CATIPLMComponent, (void**)&spCompObject);
	if (spCompObject == NULL)
		return S_FALSE;

	CATICkeObject * spCkeObject = NULL;
	rc = spCompObject->QueryInterface(IID_CATICkeObject, (void**)&spCkeObject);
	_RELEASE_PTR_(spCompObject);
	if (spCkeObject == NULL)
		return sExternalID;

	//PLM_ExternalID    majorrevision    revision
	CATCkeObjectAttrReadServices::GetValueAsString(spCkeObject, sAttrName, sExternalID);
	//cout << "==== OK ==== >> sExternalID!: " << sExternalID  << endl;

	_RELEASE_PTR_(spCkeObject);
	return sExternalID;
}

//===========================================
//	@func		: GetRefIdentificator
//	@param[in]	: CATIPLMNavReference * pRef
//	@param[in]	: CATIAdpPLMIdentificator * opiIDComp
//	@retval		: HRESULT
//	@from		: CopyRight @Comac
//  fengy 		: 2022.1.14 13:52:30  		from ref to identificator
HRESULT  fengyHelper::GetRefIdentificator(CATIPLMNavReference *ipRef, CATIAdpPLMIdentificator*& opiIDComp)
{
	HRESULT rc = E_FAIL;
	if (!ipRef)
		return rc;
	//CATAdpQueryResult * pQueryResult = pRef;

	CATIPLMComponent_var spPLMComp = ipRef;

	rc = spPLMComp->GetAdpID(opiIDComp);
	if (opiIDComp == NULL)
		return rc;

	return rc;
}


//===========================================
//	@func		: GetRefFromIdentificator
//	@param[in]	: CATIAdpPLMIdentificator * ipiIDComp
//	@param[in]	: CATIPLMNavReference * & opRef
//	@retval		: HRESULT
//	@from		: CopyRight @Comac
//  fengy 		: 2022.1.18 17:05:10  		从 id 到ref 必须打开，处于in session状态！
HRESULT  fengyHelper::GetRefFromIdentificator(CATIAdpPLMIdentificator*  ipiIDComp , CATIPLMNavReference *& opRef)
{
	HRESULT rc = E_FAIL;
	CATAdpOpenParameters ModRef(CATAdpExpandParameters::Authoring);
	CATAdpOpenParameters::LoadingMode iLoadMode = ModRef.EditMode;
	ModRef.SetLoadingMode(iLoadMode);

	CATOmbLifeCycleRootsBag ioBag;
	CATAdpOpener AdpOpener(ioBag, ModRef);

	CATIPLMNavReference* ptmpRef = NULL;
	AdpOpener.CompleteAndOpen(ipiIDComp, IID_CATIPLMNavReference, (void**)&ptmpRef);
	if (!ptmpRef)
	{
		cout << "CompleteAndOpen  ptmpRef FAILED!" << endl;
		return rc;
	}
	else
		cout << "CompleteAndOpen  ptmpRef OK!" << endl;
	opRef = ptmpRef;
	return S_OK;

}

//===========================================
//	@func		: getMaxcharindexInList
//	@param[in]	: CATListOfCATUnicodeString istrRevList
//	@retval		: int
//	@from		: CopyRight @Comac
//  fengy 		: 2022.1.18 17:51:25  		
int    fengyHelper::getMaxcharindexInList(CATListOfCATUnicodeString istrRevList)
{
	if (istrRevList.Size() == 1)
		return 1;
	int tempIndex = 1;
	for (int i = 2; i <= istrRevList.Size(); i++)
	{
		if (istrRevList[tempIndex] > istrRevList[i])
			continue;
		else
			tempIndex = i;
	}
	return tempIndex;
}

//===========================================
//	@func		: GetBigInAllVersions
//	@param[in]	: CATIAdpPLMIdentificator * iIdentificator
//	@param[in]	: CATIAdpPLMIdentificator * & ipiIDComp
//	@retval		: HRESULT
//	@from		: CopyRight @Comac
//  fengy 		: 2022.1.18 19:04:27  		以不打开的方式 来获取 最大的版本 idficator
HRESULT fengyHelper::GetBigInAllVersions(CATIAdpPLMIdentificator * iIdentificator, CATIAdpPLMIdentificator *&  opiIDComp)
{
	HRESULT rc = E_FAIL;
	if (!iIdentificator)
		return rc;
	cout << "   Retrieves all its version " << endl;
	CATLISTP(CATAdpQueryResult) listVersionedComp;
	rc = CATAdpVersioningServices::GetAllVersions(iIdentificator, listVersionedComp);

	if (FAILED(rc))
	{
		DisplayErrorMessage(rc, "CATAdpVersioningServices::GetAllVersions");
		return rc;
	}
	int QueryResSize = listVersionedComp.Size();
	cout << QueryResSize << " versions retrieved of input PLM Component" << endl;

	if (0 == QueryResSize) return rc;
	CATListOfCATUnicodeString strRevList;
	for (int k = 1; k <= QueryResSize; k++)
	{
		CATAdpQueryResult* pCurrentResult = NULL;
		pCurrentResult = listVersionedComp[k];
		if (NULL != pCurrentResult)
		{
			CATAdpAttributeSet oAttrSet;
			rc = pCurrentResult->GetAttributeSet(oAttrSet);
			if (S_OK == rc)
			{
				CATString oAttrName ;
				CATUnicodeString oAttrValue;
				int current = 0;
				while (S_OK == (oAttrSet.NextAttribute(current, oAttrName, oAttrValue)) )
				{
					cout << "Attribute Name : " << oAttrName.getUnicodeString() << endl;
					cout << "Attribute Value: " << oAttrValue.ConvertToChar() << endl << endl;
					if(oAttrName == CATString("majorrevision"))
						strRevList.Append(oAttrValue);
				}

			}
			else return rc;

			//delete pCurrentResult;		// 指向的内存空间被释放！
			//pCurrentResult = NULL;

		}
		else return rc;
	}

	int index = 0;
	index = getMaxcharindexInList(strRevList);
	if (index > 0)
	{
		CATAdpQueryResult *pQueryResult = NULL;   
		CATIAdpPLMIdentificator *pIPLMIdent = NULL;  //  To  be  Released
		pQueryResult = listVersionedComp[index];
		if (pQueryResult)
		{
			rc = pQueryResult->GetIdentifier(pIPLMIdent);
			if (SUCCEEDED(rc) && NULL != pIPLMIdent)
			{
				opiIDComp = pIPLMIdent;
				pIPLMIdent->Release();
				pIPLMIdent = NULL; 

				return S_OK;
			}
		}

	}
	return E_FAIL;
}